<!doctype html>
<html lang="fr">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="manifest" href="/manifest.webmanifest" />
  <meta name="theme-color" content="#0ea5e9" />
  <title>Mon Tableau de Bord - Presence CCRB</title>
  <script type="module" src="/auth.js?v=2" defer></script>
  <!-- Import du SDK Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- Configuration Supabase -->
  <script src="/js/supabase-config.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous" />
  <link rel="stylesheet" href="/styles.css?v=2" />
  <link rel="stylesheet" href="/contrast-fixes.css" />
  <style>
    .dashboard-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px 0;
      margin-bottom: 30px;
      border-radius: 0 0 20px 20px;
    }

    .agent-avatar {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: bold;
      margin: 0 auto 15px;
    }

    .dashboard-section {
      background: white;
      border-radius: 15px;
      padding: 30px;
      margin-bottom: 30px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .dashboard-filter-card {
      border-left: 4px solid #0ea5e9;
      background: #f8fbff;
    }

    .dashboard-filter-card label {
      font-weight: 600;
      color: #0f172a;
    }

    .dashboard-filter-card .filter-hint {
      font-size: 0.9rem;
      color: #475569;
    }

    .stats-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }

    .stats-table th,
    .stats-table td {
      padding: 12px 15px;
      text-align: left;
      border-bottom: 1px solid #e9ecef;
    }

    .stats-table th {
      background-color: #f8f9fa;
      font-weight: 600;
      color: #495057;
      text-transform: uppercase;
      font-size: 0.85rem;
      letter-spacing: 0.5px;
    }

    .stats-table tr:hover {
      background-color: #f8f9fa;
    }

    .stats-table .stat-value {
      font-weight: 700;
      font-size: 1.1rem;
      color: #007bff;
    }

    .stats-table .stat-label {
      color: #6c757d;
      font-size: 0.9rem;
    }

    .leaderboard-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }

    .leaderboard-table th,
    .leaderboard-table td {
      padding: 15px;
      text-align: left;
      border-bottom: 1px solid #e9ecef;
    }

    .leaderboard-table th {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-weight: 600;
      text-transform: uppercase;
      font-size: 0.85rem;
      letter-spacing: 0.5px;
    }

    .leaderboard-table tr:hover {
      background-color: #f8f9fa;
    }

    .leaderboard-table .rank-cell {
      font-weight: 700;
      font-size: 1.2rem;
      color: #667eea;
      width: 60px;
      text-align: center;
    }

    .leaderboard-table .agent-name-cell {
      font-weight: 600;
      color: #333;
    }

    .leaderboard-table .score-cell {
      font-weight: 700;
      font-size: 1.1rem;
      color: #28a745;
      text-align: right;
    }

    .leaderboard-table .current-agent {
      background-color: #e3f2fd;
      border-left: 4px solid #2196f3;
    }

    .stats-grid-table {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .stat-card-table {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-radius: 12px;
      padding: 20px;
      border-left: 4px solid #007bff;
    }

    .stat-card-table .stat-label {
      font-size: 0.85rem;
      color: #6c757d;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }

    .stat-card-table .stat-value {
      font-size: 2rem;
      font-weight: 700;
      color: #333;
      margin-bottom: 4px;
    }

    .stat-card-table .stat-change {
      font-size: 0.85rem;
      color: #28a745;
    }

    .section-title {
      color: #333;
      font-weight: 600;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .goal-card {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 15px;
      border-left: 4px solid #007bff;
    }

    .goal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .goal-status {
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .goal-status.active {
      background: #e3f2fd;
      color: #1976d2;
    }

    .goal-status.completed {
      background: #e8f5e8;
      color: #2e7d32;
    }

    .goal-progress {
      margin-bottom: 15px;
    }

    .goal-numbers {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
      font-size: 14px;
      color: #666;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
    }

    .stat-card {
      text-align: center;
      padding: 25px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-radius: 15px;
      border: 2px solid transparent;
      transition: all 0.3s ease;
    }

    .stat-card:hover {
      transform: translateY(-5px);
      border-color: #007bff;
      box-shadow: 0 8px 25px rgba(0, 123, 255, 0.15);
    }

    .stat-icon {
      font-size: 32px;
      margin-bottom: 15px;
    }

    .stat-value {
      font-size: 28px;
      font-weight: 700;
      color: #333;
      margin-bottom: 8px;
    }

    .stat-label {
      color: #666;
      font-size: 14px;
      font-weight: 500;
    }

    .badges-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 15px;
    }

    .badge-card {
      text-align: center;
      padding: 20px;
      border-radius: 12px;
      border: 2px solid #dee2e6;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .badge-card.earned {
      background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
      border-color: #ffc107;
      transform: scale(1.05);
    }

    .badge-card.locked {
      background: #f8f9fa;
      opacity: 0.6;
      filter: grayscale(100%);
    }

    .badge-card.earned::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      animation: shine 2s infinite;
    }

    @keyframes shine {
      0% {
        transform: translateX(-100%) translateY(-100%) rotate(45deg);
      }

      100% {
        transform: translateX(100%) translateY(100%) rotate(45deg);
      }
    }

    .badge-icon {
      font-size: 40px;
      margin-bottom: 10px;
    }

    .badge-name {
      font-weight: 600;
      margin-bottom: 8px;
      color: #333;
    }

    .badge-description {
      font-size: 12px;
      color: #666;
      margin-bottom: 8px;
    }

    .badge-date {
      font-size: 10px;
      color: #28a745;
      font-weight: 600;
    }

    .achievement-item {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 10px;
      margin-bottom: 10px;
      border-left: 4px solid #28a745;
    }

    .achievement-icon {
      font-size: 24px;
      width: 40px;
      text-align: center;
    }

    .achievement-content {
      flex: 1;
    }

    .achievement-title {
      font-weight: 600;
      color: #333;
      margin-bottom: 4px;
    }

    .achievement-description {
      font-size: 14px;
      color: #666;
      margin-bottom: 4px;
    }

    .achievement-date {
      font-size: 12px;
      color: #999;
    }

    .leaderboard-item {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 10px;
      margin-bottom: 10px;
      transition: all 0.3s ease;
    }

    .leaderboard-item:hover {
      background: #e9ecef;
      transform: translateX(5px);
    }

    .leaderboard-item.current-agent {
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
      border: 2px solid #2196f3;
      font-weight: 600;
    }

    .rank {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #007bff;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 16px;
    }

    .leaderboard-item.current-agent .rank {
      background: #ffc107;
      color: #333;
    }

    .agent-name {
      flex: 1;
      font-weight: 600;
      color: #333;
    }

    .agent-score {
      font-weight: 700;
      color: #007bff;
      font-size: 18px;
    }

    .agent-details {
      font-size: 12px;
      color: #666;
    }

    .performance-chart {
      height: 200px;
      background: #f8f9fa;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
      font-style: italic;
    }

    .motivation-quote {
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 10px;
      margin-top: 20px;
      max-width: 350px;
      margin-left: auto;
      min-height: 150px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .quote-text {
      font-style: italic;
      margin-bottom: 10px;
      font-size: 0.95rem;
      line-height: 1.4;
    }

    .quote-author {
      font-size: 0.85rem;
      opacity: 0.9;
      font-weight: 500;
    }

    @media (max-width: 768px) {
      .motivation-quote {
        max-width: 100%;
        margin: 20px 0 0 0;
      }
    }

    .monthly-report {
      font-size: 0.95rem;
    }

    .monthly-report .card {
      border: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    .monthly-report .card-header {
      font-weight: 600;
    }

    .ai-summary-content {
      font-size: 1rem;
      line-height: 1.8;
      color: #333;
      border-left: 4px solid #818cf8;
      padding-left: 16px;
    }

    .report-header {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    }

    /* Styles pour le tableau de pr√©sence */
    .table-responsive {
      border-radius: 8px;
      overflow: hidden;
    }

    .table thead th {
      border-bottom: 2px solid #dee2e6;
      font-weight: 600;
      text-transform: uppercase;
      font-size: 0.85rem;
      letter-spacing: 0.5px;
    }

    .table tbody tr {
      transition: background-color 0.2s ease;
    }

    .table tbody tr:hover {
      background-color: #f8f9fa;
    }

    .table tbody td {
      vertical-align: middle;
    }

    .report-layout {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .report-section {
      background: #fff;
      border-radius: 18px;
      border: 1px solid #e2e8f0;
      padding: 24px;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.08);
    }

    .report-section-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 16px;
      margin-bottom: 18px;
    }

    .report-section-header h5 {
      margin: 0;
      font-weight: 600;
      color: #0f172a;
    }

    .report-section-header small {
      display: block;
      color: #64748b;
      font-size: 0.85rem;
    }

    .report-cover {
      background: linear-gradient(135deg, #0f172a, #1d4ed8);
      color: #fff;
      border: none;
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.5);
    }

    .report-cover .report-section-header h5 {
      color: #fff;
    }

    .report-cover .report-section-header small {
      color: rgba(255, 255, 255, 0.85);
    }

    .report-cover-details {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-top: 12px;
    }

    .report-cover-details .detail {
      flex: 1 1 200px;
      background: rgba(255, 255, 255, 0.12);
      border-radius: 14px;
      padding: 14px 18px;
    }

    .report-cover-details .label {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      opacity: 0.8;
      margin-bottom: 4px;
    }

    .report-cover-details .value {
      font-size: 1.05rem;
      font-weight: 600;
    }

    .report-metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 16px;
    }

    .report-metric-card {
      border-radius: 16px;
      border: 1px solid #e2e8f0;
      padding: 18px;
      text-align: center;
      background: #f8fafc;
    }

    .report-metric-card .metric-value {
      font-size: 2rem;
      font-weight: 700;
      color: #111827;
    }

    .report-metric-card .metric-label {
      text-transform: uppercase;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      color: #64748b;
    }

    .report-grid-2 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 24px;
    }

    .report-photo-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
    }

    .report-photo-item {
      border-radius: 18px;
      overflow: hidden;
      border: 1px solid #e2e8f0;
      background: #0f172a;
      color: #fff;
    }

    .report-photo-item img {
      width: 100%;
      height: 200px;
      object-fit: cover;
      display: block;
    }

    .report-photo-item figcaption {
      padding: 14px 18px;
    }

    .report-photo-item .photo-meta {
      display: block;
      font-size: 0.8rem;
      opacity: 0.85;
      margin-top: 6px;
    }

    .report-chip-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .report-chip {
      background: #e0e7ff;
      color: #312e81;
      border-radius: 999px;
      padding: 6px 14px;
      font-size: 0.8rem;
      font-weight: 600;
    }

    @media (max-width: 576px) {
      .report-section {
        padding: 18px;
      }

      .report-metric-card .metric-value {
        font-size: 1.5rem;
      }
    }
  </style>
</head>

<body>
  <!-- Barre de navigation circulaire -->
  <script src="/js/circular-nav-component.js"></script>
  <circular-nav></circular-nav>

  <!-- Main Content -->
  <main class="main-content">
    <!-- En-t√™te du tableau de bord -->
    <div class="dashboard-header">
      <div class="container">
        <div class="row align-items-center">
          <div class="col-md-8">
            <div class="agent-avatar" id="agent-avatar">A</div>
            <h2 id="agent-name">Agent</h2>
            <p id="agent-role" class="mb-0">R√¥le</p>
          </div>
          <div class="col-md-4 text-end">
            <div class="motivation-quote">
              <div class="quote-text" id="motivation-quote">
                "L'excellence n'est jamais un accident. C'est toujours le r√©sultat d'une intention √©lev√©e, d'un effort
                sinc√®re et d'une ex√©cution intelligente."
              </div>
              <div class="quote-author">- Aristote</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-fluid" style="max-width: 100%; padding: 0 50px">
      <div class="dashboard-section dashboard-filter-card mb-4">
        <h3 class="section-title mb-3">
          <i class="bi bi-funnel"></i>
          Filtrer l'affichage
        </h3>
        <div class="row g-3 align-items-end">
          <div class="col-md-4">
            <label for="report-project-select" class="form-label">Projet / Programme</label>
            <select id="report-project-select" class="form-select">
              <option value="">S√©lectionnez un projet</option>
            </select>
          </div>
          <div class="col-md-4">
            <label for="report-agent-select" class="form-label">Agent √† analyser</label>
            <select id="report-agent-select" class="form-select">
              <option value="">Chargement...</option>
            </select>
          </div>
          <div class="col-md-3">
            <label for="report-month-select" class="form-label">Mois de rapportage</label>
            <input type="month" id="report-month-select" class="form-control" />
          </div>
          <div class="col-md-1">
            <button id="generate-report-btn" class="btn btn-primary w-100">
              <i class="bi bi-arrow-repeat me-2"></i>
              Appliquer le filtre
            </button>
          </div>
        </div>
        <p class="filter-hint mt-3 mb-0">
          S√©lectionnez un projet, un agent et le mois de rapportage souhait√©, puis appliquez le filtre pour g√©n√©rer un
          rapport conforme aux normes internes.
        </p>
      </div>

      <div id="dashboard-locked-notice" class="alert alert-info">
        <i class="bi bi-info-circle me-2"></i>
        Choisissez un agent et un mois avec le filtre ci-dessus pour afficher toutes les sections du tableau de bord.
      </div>

      <div id="dashboard-content" class="d-none">
        <!-- Section des objectifs -->
        <div class="dashboard-section">
          <h3 class="section-title">
            <i class="bi bi-bullseye"></i>
            Mes Objectifs
          </h3>
          <div id="goals-container">
            <!-- Les objectifs seront charg√©s ici -->
          </div>
        </div>

        <!-- Section des statistiques -->
        <div class="dashboard-section">
          <h3 class="section-title">
            <i class="bi bi-graph-up"></i>
            √âvolution de ma pr√©sence
          </h3>
          <div class="mb-3">
            <label for="period-select" class="form-label">P√©riode :</label>
            <select id="period-select" class="form-select" style="max-width: 200px">
              <option value="7">7 derniers jours</option>
              <option value="14">14 derniers jours</option>
              <option value="30" selected>30 derniers jours</option>
            </select>
          </div>
          <div class="chart-container" style="position: relative; height: 300px">
            <canvas id="presenceChart"></canvas>
          </div>

          <div class="mt-4" id="stats-container">
            <!-- Les statistiques en tableau seront charg√©es ici -->
          </div>
        </div>

        <!-- Section des performances -->
        <div class="dashboard-section">
          <h3 class="section-title">
            <i class="bi bi-speedometer2"></i>
            Mes Performances
          </h3>
          <div id="performance-container">
            <div class="text-center py-4">
              <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Chargement...</span>
              </div>
              <p class="mt-2">Chargement des performances...</p>
            </div>
          </div>
        </div>

        <!-- Section Rapport Mensuel -->
        <div class="dashboard-section">
          <div class="d-flex justify-content-between align-items-center mb-3">
            <h3 class="section-title mb-0">
              <i class="bi bi-file-text"></i>
              Rapport Mensuel
            </h3>
            <div id="report-actions" class="d-none">
              <button type="button" class="btn btn-success btn-sm me-2" onclick="downloadReportHTML()"
                title="T√©l√©charger le rapport en HTML">
                <i class="bi bi-file-earmark-arrow-down me-1"></i>
                T√©l√©charger HTML
              </button>
              <button type="button" class="btn btn-primary btn-sm" onclick="printReport()" title="Imprimer le rapport">
                <i class="bi bi-printer me-1"></i>
                Imprimer
              </button>
            </div>
          </div>
          <div id="monthly-report-container">
            <div class="text-center py-4 text-muted">
              <i class="bi bi-info-circle me-2"></i>
              S√©lectionnez un agent et un mois avec le filtre en haut de page, puis cliquez sur "Appliquer le filtre"
              pour afficher le rapport mensuel.
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
    crossorigin="anonymous"></script>

  <!-- Script de nettoyage des ressources -->
  <script>
    // Syst√®me de nettoyage des ressources
    (function () {
      'use strict';

      // D√©claration des variables globales
      let dashboardAgentId = null;
      let currentUser = null;
      let dashboardProjectFilter = null;
      let leaderboardProjects = [];
      let leaderboardProjectFilter = null;
      let leaderboardCache = [];
      let projectSelectTouched = false;
      let dashboardMonthFilter = null;
      let dashboardSelectedAgent = null;

      const cleanupRegistry = {
        eventListeners: new Map(),
        intervals: new Set(),
        timeouts: new Set(),
        requests: new Set(),

        // Ajouter un √©couteur d'√©v√©nement avec nettoyage automatique
        addEventListener(element, event, handler, options) {
          if (!this.eventListeners.has(element)) {
            this.eventListeners.set(element, []);

            // Ajouter un gestionnaire pour nettoyer lors de la suppression de l'√©l√©ment
            const observer = new MutationObserver((mutations, obs) => {
              if (!document.body.contains(element)) {
                this.cleanupElement(element);
                obs.disconnect();
              }
            });

            if (element.parentNode) {
              observer.observe(element.parentNode, { childList: true });
            }
          }

          element.addEventListener(event, handler, options);
          this.eventListeners.get(element).push({ event, handler, options });

          // Retourner une fonction de nettoyage
          return () => this.removeEventListener(element, event, handler, options);
        },

        // Supprimer un √©couteur d'√©v√©nement
        removeEventListener(element, event, handler, options) {
          if (element && this.eventListeners.has(element)) {
            element.removeEventListener(event, handler, options);
            const listeners = this.eventListeners.get(element);
            const index = listeners.findIndex(
              l => l.event === event && l.handler === handler && l.options === options
            );
            if (index > -1) {
              listeners.splice(index, 1);
            }
            if (listeners.length === 0) {
              this.eventListeners.delete(element);
            }
          }
        },

        // Nettoyer tous les √©couteurs d'un √©l√©ment
        cleanupElement(element) {
          if (this.eventListeners.has(element)) {
            const listeners = this.eventListeners.get(element) || [];
            listeners.forEach(({ event, handler, options }) => {
              element.removeEventListener(event, handler, options);
            });
            this.eventListeners.delete(element);
          }
        },

        // Envelopper setTimeout pour un nettoyage automatique
        wrapSetTimeout() {
          const original = window.setTimeout;
          window.setTimeout = (handler, delay, ...args) => {
            const id = original(handler, delay, ...args);
            this.timeouts.add(id);
            return id;
          };
        },

        // Envelopper setInterval pour un nettoyage automatique
        wrapSetInterval() {
          const original = window.setInterval;
          window.setInterval = (handler, delay, ...args) => {
            const id = original(handler, delay, ...args);
            this.intervals.add(id);
            return id;
          };
        },

        // Envelopper fetch pour annuler les requ√™tes en cours
        wrapFetch() {
          const originalFetch = window.fetch;
          window.fetch = (resource, init = {}) => {
            const controller = new AbortController();
            const signal = controller.signal;

            const request = originalFetch(resource, { ...init, signal });
            this.requests.add(controller);

            // Supprimer la r√©f√©rence une fois la requ√™te termin√©e
            request.finally(() => this.requests.delete(controller));

            return request;
          };
        },

        // Nettoyer toutes les ressources
        cleanup() {
          // Nettoyer les √©couteurs d'√©v√©nements
          this.eventListeners.forEach((_, element) => this.cleanupElement(element));
          this.eventListeners.clear();

          // Nettoyer les intervalles
          this.intervals.forEach(id => clearInterval(id));
          this.intervals.clear();

          // Nettoyer les timeouts
          this.timeouts.forEach(id => clearTimeout(id));
          this.timeouts.clear();

          // Annuler les requ√™tes en cours
          this.requests.forEach(controller => controller.abort());
          this.requests.clear();
        },

        // Initialiser le syst√®me de nettoyage
        init() {
          this.wrapSetTimeout();
          this.wrapSetInterval();
          this.wrapFetch();

          // Nettoyer lors du d√©chargement de la page
          window.addEventListener('unload', () => this.cleanup());

          // Nettoyer lors de la navigation (pour les SPA)
          if (window.history.pushState) {
            const originalPushState = history.pushState;
            history.pushState = function () {
              originalPushState.apply(this, arguments);
              window.dispatchEvent(new Event('locationchange'));
            };

            window.addEventListener('popstate', () => {
              window.dispatchEvent(new Event('locationchange'));
            });

            window.addEventListener('locationchange', () => {
              this.cleanup();
            });
          }
        },
      };

      // Initialiser le syst√®me de nettoyage
      cleanupRegistry.init();

      // Exposer l'API de nettoyage globalement
      window.CleanupRegistry = cleanupRegistry;
    })();

    // Initialisation de l'application
    (function () {
      'use strict';

      // Code d'initialisation principal
      document.addEventListener('DOMContentLoaded', function () {
        console.log('Application initialis√©e');
        // Initialiser les composants ici si n√©cessaire
      });

      // Exposer les fonctions globales
      window.refreshDashboard = function () {
        console.log('Rafra√Æchissement du tableau de bord');
        // Impl√©mentation de la fonction de rafra√Æchissement
      };

    })();
  </script>
  <!-- Chart.js pour les graphiques -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <!-- Int√©gration de Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="/js/supabase-config.js"></script>
  <script type="module" src="/app.js"></script>
  <!-- Tableau de bord agent personnalis√© -->
  <script type="module" src="/agent-dashboard.js"></script>
  <script type="module">
    async function loadMotivationModule() {
      try {
        const motivationModule = await import('/js/motivation.js');
        const { getRandomQuote } = motivationModule;
        
        // Afficher une citation al√©atoire
        function displayRandomQuote() {
          const quote = getRandomQuote();
          const quoteElement = document.getElementById('motivation-quote');
          if (quoteElement) {
            quoteElement.innerHTML = `
              <div class="quote-text">"${quote.text}"</div>
              <div class="quote-author">‚Äî ${quote.author}</div>
            `;
          }
        }
        
        // Afficher une citation au chargement de la page
        displayRandomQuote();
        
        // Rendre la fonction disponible globalement
        window.displayRandomQuote = displayRandomQuote;
      } catch (error) {
        console.error('Erreur lors du chargement du module de motivation:', error);
      }
    }
    
    // Charger le module au d√©marrage
    loadMotivationModule();
  </script>
  <script>
    // Variables globales
    let dashboardAgents = [];
    let dashboardAgentId = null;
    let dashboardSelectedAgent = null;
    let dashboardMonthValue = null;
    let dashboardProjectFilter = '';
    let monthlyReportRequestId = 0;
    let leaderboardCache = [];
    let leaderboardProjects = [];
    let leaderboardProjectFilter = null;
    let lastMonthlyReportParams = { agentId: null, monthValue: null };
    let aiGenerationInProgress = false;
    let projectSelectTouched = false;

    const REPORT_RESULT_LABELS = {
      realise: 'R√©alis√©',
      realisee: 'R√©alis√©',
      'realise partiellement': 'Partiellement r√©alis√©',
      partiellement_realise: 'Partiellement r√©alis√©',
      en_cours: 'En cours',
      non_realise: 'Non r√©alis√©',
      planifie: 'Planifi√©',
      planned: 'Planifi√©'
    };

    const REPORT_ACTIVITY_STATUS_GROUPS = {
      realized: new Set(['realise', 'realisee', 'completed', 'complete', 'terminee', 'termine', 'fait', 'done']),
      notRealized: new Set(['non_realise', 'non_realisee', 'annule', 'annulee', 'cancelled', 'pas_fait', 'nonrealise']),
      inProgress: new Set(['en_cours', 'encours', 'in_progress', 'pending']),
      partiallyRealized: new Set(['partiellement_realise', 'partiellement_realisee', 'partially_completed', 'partially']),
      planned: new Set(['planifie', 'planifiee', 'planified', 'planifiees', 'planifie_en_cours'])
    };

    function normalizeActivityStatus(value) {
      if (!value) return '';
      return String(value)
        .trim()
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/\s+/g, '_');
    }

    function detectActivityStatus(value) {
      const normalized = normalizeActivityStatus(value);
      if (!normalized) return 'unknown';
      if (REPORT_ACTIVITY_STATUS_GROUPS.realized.has(normalized)) return 'realized';
      if (REPORT_ACTIVITY_STATUS_GROUPS.notRealized.has(normalized)) return 'notRealized';
      if (REPORT_ACTIVITY_STATUS_GROUPS.inProgress.has(normalized)) return 'inProgress';
      if (REPORT_ACTIVITY_STATUS_GROUPS.partiallyRealized.has(normalized)) return 'partiallyRealized';
      if (REPORT_ACTIVITY_STATUS_GROUPS.planned.has(normalized)) return 'planned';
      return 'unknown';
    }

    /**
     * √âchappe les caract√®res sp√©ciaux HTML dans une cha√Æne de caract√®res
     * @param {string} value - La cha√Æne √† √©chapper
     * @returns {string} La cha√Æne √©chapp√©e
     */
    function escapeHtml(value) {
      if (value === null || value === undefined) {
        return '';
      }
      const stringValue = String(value);
      return stringValue
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function buildMonthRange(monthValue) {
      const today = new Date();
      let year = today.getFullYear();
      let monthIndex = today.getMonth();

      if (typeof monthValue === 'string' && /^\d{4}-\d{2}$/.test(monthValue)) {
        const [y, m] = monthValue.split('-').map(Number);
        if (y >= 2000 && m >= 1 && m <= 12) {
          year = y;
          monthIndex = m - 1;
        }
      }

      const startDate = new Date(Date.UTC(year, monthIndex, 1, 0, 0, 0, 0));
      const endDate = new Date(Date.UTC(year, monthIndex + 1, 0, 23, 59, 59, 999));
      return {
        value: `${year}-${String(monthIndex + 1).padStart(2, '0')}`,
        startDate,
        endDate,
        startIso: startDate.toISOString(),
        endIso: endDate.toISOString()
      };
    }

    function countWorkingDaysBetween(startDate, endDate) {
      const cursor = new Date(startDate);
      const end = new Date(endDate);
      let total = 0;
      while (cursor <= end) {
        const day = cursor.getUTCDay();
        if (day >= 1 && day <= 5) {
          total += 1;
        }
        cursor.setUTCDate(cursor.getUTCDate() + 1);
      }
      return total;
    }

    // Alias pour compatibilit√©
    function countWorkingDays(startDate, endDate) {
      return countWorkingDaysBetween(startDate, endDate);
    }

    function formatMonthLabel(monthValue) {
      if (!monthValue) return '';
      const [yearStr, monthStr] = String(monthValue).split('-');
      if (!yearStr || !monthStr) return monthValue;
      const date = new Date(Date.UTC(Number(yearStr), Number(monthStr) - 1, 1));
      return date.toLocaleDateString('fr-FR', { month: 'long', year: 'numeric' });
    }

    function formatProjectDisplay(value) {
      return (value || 'Projet non attribu√©').toString().trim() || 'Projet non attribu√©';
    }

    function normalizeProjectIdentifier(value) {
      return (value || '')
        .toString()
        .trim()
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9]+/g, ' ')
        .trim();
    }

    /**
     * Met √† jour la liste d√©roulante des projets avec les projets uniques des agents
     * @param {Array} agentList - Liste des agents avec leurs projets
     */
    function populateProjectFilterOptions(agentList = []) {
      console.log('üîÑ Mise √† jour de la liste des projets...', agentList);
      const select = document.getElementById('report-project-select');
      if (!select) {
        console.error('‚ùå √âl√©ment select des projets non trouv√©');
        return;
      }

      try {
        // S'assurer que agentList est un tableau
        if (!Array.isArray(agentList)) {
          console.warn('‚ö†Ô∏è La liste des agents n\'est pas un tableau:', agentList);
          agentList = [];
        }

        console.log(`üìã Nombre d'agents √† traiter: ${agentList.length}`);

        // R√©cup√©rer tous les projets uniques, tri√©s par ordre alphab√©tique
        const projects = [];

        // Extraire les projets de chaque agent
        agentList.forEach((agent, index) => {
          if (!agent) {
            console.warn(`‚ö†Ô∏è Agent ${index} est null ou undefined`);
            return;
          }

          // Essayer de trouver un nom de projet dans diff√©rentes propri√©t√©s
          const projectName = formatProjectDisplay(
            agent.project_name ||
            agent.project ||
            (agent.projects && agent.projects[0]?.name) ||
            ''
          ).trim();

          console.log(`  Agent ${index} (ID=${agent.id}): project_name="${agent.project_name}", project="${agent.project}", projectName format√©="${projectName}"`);

          if (projectName &&
            projectName !== 'Projet non attribu√©' &&
            projectName !== 'Non attribu√©' &&
            !projects.includes(projectName)) {
            projects.push(projectName);
            console.log(`  ‚úÖ Projet ajout√©: "${projectName}"`);
          }
        });

        // Trier les projets par ordre alphab√©tique
        const sortedProjects = [...projects].sort((a, b) =>
          a.localeCompare(b, 'fr', { sensitivity: 'base' })
        );

        // Ajouter l'option par d√©faut
        const options = ['<option value="">Tous les projets</option>'];

        // Ajouter l'option d'administration si n√©cessaire
        const hasAdminAccess = agentList.some(agent => {
          const role = (agent.role || '').toLowerCase();
          const project = (agent.project_name || agent.project || '').toLowerCase();
          return role === 'admin' || project.includes('admin');
        });

        if (hasAdminAccess) {
          options.push('<option value="Administration">Administration</option>');
        }

        // Ajouter les autres projets
        sortedProjects.forEach(project => {
          if (project && !options.some(opt => opt.includes(`value="${project}"`))) {
            options.push(`<option value="${project}">${project}</option>`);
          }
        });

        // Mettre √† jour le select
        select.innerHTML = options.join('');

        console.log(`üìù Options de projets g√©n√©r√©es (${options.length} options):`, options);

        // Restaurer la s√©lection pr√©c√©dente si elle existe toujours
        const currentProject = dashboardProjectFilter || '';
        const projectExists = currentProject &&
          (currentProject === 'Administration' ||
            sortedProjects.some(p => p === currentProject));

        if (projectExists) {
          select.value = currentProject;
          console.log(`‚úÖ Projet restaur√©: "${currentProject}"`);
        } else if (sortedProjects.length === 1) {
          // S√©lectionner le premier projet par d√©faut s'il n'y a qu'un seul projet
          select.value = sortedProjects[0];
          dashboardProjectFilter = sortedProjects[0];
          console.log(`‚úÖ Projet unique s√©lectionn√©: "${sortedProjects[0]}"`);
        } else {
          select.value = ''; // Afficher "Tous les projets"
          console.log(`‚úÖ S√©lection par d√©faut: "Tous les projets"`);
        }

        console.log(`‚úÖ Liste des projets mise √† jour avec ${sortedProjects.length} projets:`, sortedProjects);
      } catch (error) {
        console.error('Erreur lors de la mise √† jour des projets:', error);
        select.innerHTML = '<option value="">Erreur de chargement des projets</option>';
      }
    }

    /**
     * Synchronise la s√©lection du projet avec l'agent s√©lectionn√©
     * @param {Object} agent - L'agent s√©lectionn√©
     * @param {Object} options - Options de configuration
     * @param {boolean} [options.force=false] - Forcer la mise √† jour m√™me si le filtre a √©t√© modifi√© manuellement
     */
    function syncProjectSelectWithAgent(agent, { force = false } = {}) {
      console.log('Synchronisation du projet avec l\'agent:', agent);
      const select = document.getElementById('report-project-select');
      if (!select || !agent) {
        console.warn('Impossible de synchroniser le projet: select ou agent manquant');
        return;
      }

      // R√©cup√©rer le nom du projet format√©
      const projectName = formatProjectDisplay(
        agent.project_name || agent.project || agent.projectName || ''
      );

      console.log(`Projet de l'agent: "${projectName}"`);

      // Ne rien faire si le projet est vide ou non attribu√©, sauf si on force
      if ((!projectName || projectName === 'Projet non attribu√©' || projectName === 'Non attribu√©') && !force) {
        console.log('Aucun projet valide pour cet agent');
        return;
      }

      // V√©rifier si le projet existe dans la liste d√©roulante
      const projectExists = Array.from(select.options).some(opt => opt.value === projectName);

      // Mettre √† jour la s√©lection si n√©cessaire
      if ((!projectSelectTouched || force || !dashboardProjectFilter) && projectName) {
        // Si le projet existe dans la liste, le s√©lectionner
        if (projectExists) {
          console.log(`S√©lection du projet: ${projectName}`);
          select.value = projectName;
          dashboardProjectFilter = projectName;
        }
        // Sinon, essayer de trouver un projet similaire
        else {
          const similarProject = findSimilarProject(projectName, select.options);
          if (similarProject) {
            console.log(`Projet similaire trouv√©: ${similarProject} (original: ${projectName})`);
            select.value = similarProject;
            dashboardProjectFilter = similarProject;
          } else if (force) {
            // Si on force et qu'aucun projet similaire n'est trouv√©, s√©lectionner "Tous les projets"
            console.log('Aucun projet similaire trouv√©, s√©lection de "Tous les projets"');
            select.value = '';
            dashboardProjectFilter = '';
          }
        }

        // Mettre √† jour le filtre du classement si n√©cessaire
        updateLeaderboardProjectFilter(projectName);
      }
    }

    /**
     * Trouve un projet similaire dans la liste des options
     * @param {string} projectName - Nom du projet √† rechercher
     * @param {HTMLOptionsCollection} options - Collection d'options de s√©lection
     * @returns {string|null} - Le nom du projet similaire ou null si non trouv√©
     */
    function findSimilarProject(projectName, options) {
      if (!projectName || !options) return null;

      const normalizedSearch = projectName
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '');

      for (let i = 0; i < options.length; i++) {
        const option = options[i];
        if (!option.value) continue;

        const normalizedOption = option.text
          .toLowerCase()
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, '');

        if (normalizedOption.includes(normalizedSearch) ||
          normalizedSearch.includes(normalizedOption)) {
          return option.value;
        }
      }

      return null;
    }

    /**
     * Met √† jour le filtre de projet pour le classement
     * @param {string} projectName - Nom du projet √† utiliser comme filtre
     */
    function updateLeaderboardProjectFilter(projectName) {
      if (!projectName) return;

      // V√©rifier si le projet existe dans la liste des projets du classement
      if (leaderboardProjects.length === 0 || leaderboardProjects.includes(projectName)) {
        console.log(`Mise √† jour du filtre du classement avec le projet: ${projectName}`);
        leaderboardProjectFilter = projectName;

        // Mettre √† jour l'affichage du classement si n√©cessaire
        if (leaderboardCache.length > 0) {
          renderLeaderboardTable();
        }
      }
    }

    async function fetchMonthlyCheckins(agentId, monthRange) {
      console.log('üîç fetchMonthlyCheckins appel√© avec:', { agentId, monthRange });
      if ((agentId ?? null) === null || !monthRange) {
        console.warn('‚ö†Ô∏è fetchMonthlyCheckins: param√®tres manquants', { agentId, monthRange });
        return [];
      }
      try {
        const params = new URLSearchParams({
          from: monthRange.startIso,
          to: monthRange.endIso
        });
        if (agentId !== undefined && agentId !== null && agentId !== '') {
          params.set('user_id', agentId);
        }
        const url = `/api/checkins?${params.toString()}`;
        console.log('üì° Requ√™te checkins:', url);
        const response = await fetch(url, {
          headers: { 'Content-Type': 'application/json' }
        });
        console.log('üì• R√©ponse checkins: status=', response.status);
        if (!response.ok) throw new Error(`Erreur ${response.status}`);
        const data = await response.json();
        console.log('üì¶ Donn√©es checkins brutes:', data);
        const result = Array.isArray(data) ? data : (data.checkins || data.data || []);
        console.log('‚úÖ Checkins extraits:', result.length, 'enregistrements');
        return result;
      } catch (error) {
        console.warn('‚ùå fetchMonthlyCheckins error:', error);
        return [];
      }
    }

    function summarizePresenceFromCheckins(checkins, monthRange) {
      if (!checkins || checkins.length === 0 || !monthRange) return null;
      const workedDays = new Set();
      checkins.forEach(checkin => {
        const rawDate = checkin?.created_at || checkin?.timestamp || checkin?.checkin_time;
        if (!rawDate) return;
        const date = new Date(rawDate);
        if (Number.isNaN(date.getTime())) return;
        workedDays.add(date.toISOString().split('T')[0]);
      });

      const totalCheckins = checkins.length;
      const workingDays = countWorkingDaysBetween(monthRange.startDate, monthRange.endDate);
      const worked = workedDays.size;
      const presenceRate = workingDays > 0 ? Math.round((worked / workingDays) * 1000) / 10 : 0;
      const average = worked > 0 ? Math.round((totalCheckins / worked) * 10) / 10 : totalCheckins;

      return {
        totalCheckins,
        workedDays: worked,
        workingDays,
        presenceRate,
        averageCheckinsPerDay: average,
        permissionDays: 0
      };
    }

    function parsePlanificationDate(plan) {
      if (!plan) return null;
      const candidates = [
        plan.date,
        plan.date_planification,
        plan.datePlanification,
        plan.day,
        plan.created_at,
        plan.createdAt,
        plan.planned_on
      ];

      for (const rawValue of candidates) {
        if (!rawValue) continue;
        const asDate = new Date(rawValue);
        if (!Number.isNaN(asDate.getTime())) {
          return asDate;
        }

        if (typeof rawValue === 'string') {
          const normalized = new Date(`${rawValue}T00:00:00`);
          if (!Number.isNaN(normalized.getTime())) {
            return normalized;
          }
        }
      }

      return null;
    }

    async function fetchMonthlyPlanifications(agentId, monthRange, extraFilters = {}) {
      if (!monthRange) return [];
      try {
        const params = new URLSearchParams({
          from: monthRange.startIso.split('T')[0],
          to: monthRange.endIso.split('T')[0]
        });
        if (agentId !== undefined && agentId !== null && agentId !== '') {
          params.set('agent_id', agentId);
          params.set('user_id', agentId); // compatibilit√© legacy
        }
        if (extraFilters.projectName) {
          params.set('project_name', extraFilters.projectName);
        }
        const response = await fetch(`/api/planifications?${params.toString()}`, {
          headers: { 'Content-Type': 'application/json' }
        });
        if (!response.ok) throw new Error(`Erreur ${response.status}`);
        const data = await response.json();
        const items = Array.isArray(data)
          ? data
          : Array.isArray(data?.items)
            ? data.items
            : Array.isArray(data?.planifications)
              ? data.planifications
              : Array.isArray(data?.data)
                ? data.data
                : [];

        if (!items.length) return [];

        const normalizedAgentId = agentId !== undefined && agentId !== null && agentId !== ''
          ? String(agentId)
          : null;
        const startTime = monthRange.startDate.getTime();
        const endTime = monthRange.endDate.getTime();

        return items.filter(plan => {
          const planDate = parsePlanificationDate(plan);
          if (!planDate) return false;
          const time = planDate.getTime();
          if (time < startTime || time > endTime) return false;
          if (!normalizedAgentId) return true;
          const planAgentId = plan.agent_id ?? plan.user_id ?? plan.userId ?? plan.agentId;
          return String(planAgentId ?? '') === normalizedAgentId;
        });
      } catch (error) {
        console.warn('fetchMonthlyPlanifications error:', error);
        return [];
      }
    }

    async function fetchPermissionDaysRecord(agentId, monthValue) {
      try {
        if (!agentId || !monthValue) return null;
        const params = new URLSearchParams({
          agent_id: agentId,
          month: monthValue
        });
        const response = await fetch(`/api/permission-days?${params.toString()}`, {
          headers: { 'Content-Type': 'application/json' }
        });
        if (!response.ok) throw new Error(`Erreur ${response.status}`);
        const result = await response.json();
        const records = Array.isArray(result?.data)
          ? result.data
          : Array.isArray(result)
            ? result
            : [];
        return records.length > 0 ? records[0] : null;
      } catch (error) {
        console.warn('Erreur r√©cup√©ration jours permissionnaires:', error);
        return null;
      }
    }

    function summarizeActivitiesFromPlanifications(planifications = []) {
      if (!planifications.length) return null;

      const list = planifications.map(plan => ({
        id: plan.id,
        date: plan.date || plan.date_planification || plan.datePlanification || plan.day || plan.created_at,
        description: plan.description_activite || plan.activity_name || plan.description || 'Activit√© non sp√©cifi√©e',
        result: plan.resultat_journee || plan.status || plan.result || 'planifie',
        project: plan.project_name || plan.project || null
      })).filter(item => !!item.date);

      // Compter les statuts
      const statusCounters = {
        total: list.length,
        realized: 0,        // R√©alis√©
        notRealized: 0,     // Non r√©alis√©
        inProgress: 0,      // En cours
        partiallyRealized: 0, // Partiellement r√©alis√©
        planned: 0,         // Planifi√©
        unknown: 0          // Statut inconnu
      };

      list.forEach(item => {
        const status = detectActivityStatus(item.result);
        if (statusCounters[status] !== undefined) {
          statusCounters[status] += 1;
        } else {
          statusCounters.unknown += 1;
        }
      });

      // Calculer le nombre d'activit√©s non r√©alis√©es
      const uncompletedActivities = 
        statusCounters.notRealized + 
        statusCounters.planned +
        (statusCounters.unknown > 0 ? statusCounters.unknown : 0);

      const breakdownMap = new Map();
      list.forEach(item => {
        const key = normalizeActivityStatus(item.result || 'planifie');
        breakdownMap.set(key, (breakdownMap.get(key) || 0) + 1);
      });

      const breakdown = Array.from(breakdownMap.entries())
        .map(([key, count]) => ({
          key,
          label: REPORT_RESULT_LABELS[key] || key.replace(/_/g, ' '),
          count,
          percentage: list.length ? Math.round((count / list.length) * 1000) / 10 : 0
        }))
        .sort((a, b) => b.count - a.count);

      // Calculer le taux d'ex√©cution (TEP)
      const executionRate = statusCounters.total > 0
        ? Math.round((statusCounters.realized / statusCounters.total) * 1000) / 10
        : 0;

      return {
        total: list.length,
        breakdown,
        performance: {
          executionRate,
          uncompletedActivities,  // Ajout du nombre d'activit√©s non r√©alis√©es
          realized: statusCounters.realized,
          notRealized: statusCounters.notRealized,
          inProgress: statusCounters.inProgress,
          partiallyRealized: statusCounters.partiallyRealized,
          plannedOnly: statusCounters.planned,
          withoutStatus: statusCounters.unknown
        }
      };
    }

    // R√©cup√©rer les informations de l'utilisateur depuis l'API
    async function getUserProfile() {
      try {
        console.log('üë§ getUserProfile: R√©cup√©ration du profil utilisateur...');
        const headers = {
          'Content-Type': 'application/json'
        };
        const token = localStorage.getItem('jwt');
        if (token) {
          headers['Authorization'] = `Bearer ${token}`;
          console.log('üîë Token JWT trouv√©:', token.substring(0, 10) + '...');
        } else {
          console.warn('‚ö†Ô∏è Aucun token JWT trouv√© dans localStorage');
        }

        console.log('üì° Requ√™te vers /api/profile...');
        const response = await fetch('/api/profile', { headers });

        console.log(`üì• R√©ponse /api/profile: status=${response.status}, ok=${response.ok}`);

        if (!response.ok) {
          if (response.status === 401) {
            console.error('‚ùå Non authentifi√©, redirection vers /login.html');
            window.location.href = '/login.html';
            return null;
          }
          throw new Error(`Erreur ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        console.log('üì¶ Donn√©es profil re√ßues:', data);

        // L'API peut retourner { success: true, user: {...} } ou directement {...}
        const profile = data.user || data;

        if (!profile) {
          throw new Error('Profil utilisateur introuvable');
        }

        console.log(`‚úÖ Profil charg√©: ID=${profile.id}, Email=${profile.email}, Role=${profile.role}`);
        return profile;
      } catch (error) {
        console.error('Erreur inattendue dans getUserProfile:', error);
        return null;
      }
    }

    // Initialiser la page du tableau de bord
    document.addEventListener('DOMContentLoaded', () => {
      setDashboardLocked(true);
      initializeDashboardPage();
    });

    function initializeDashboardPage() {
      console.log('üöÄ Initialisation de la page du tableau de bord...');

      // Cr√©er un objet agentDashboard minimal si non d√©fini
      if (!window.agentDashboard) {
        console.log('‚ö†Ô∏è window.agentDashboard non d√©fini, cr√©ation d\'un objet minimal');
        window.agentDashboard = {
          renderDashboard: function () { console.log('renderDashboard appel√©'); },
          getCurrentAgent: function () { return dashboardSelectedAgent; },
          setAgent: async function (agent) {
            dashboardSelectedAgent = agent;
            dashboardAgentId = String(agent?.id || '');
            console.log('Agent d√©fini:', agent);
          },
          loadAgentData: async function () { return Promise.resolve(); }
        };
      }

      // Set default month
      const today = new Date();
      const monthInput = document.getElementById('report-month-select');
      if (monthInput) {
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const year = today.getFullYear();
        monthInput.value = `${year}-${month}`;
        dashboardMonthFilter = monthInput.value;
      }

      // Load user info and agents
      console.log('üì• Chargement des informations utilisateur...');
      loadAgentInfo().then(() => {
        console.log('‚úÖ loadAgentInfo termin√©, chargement des agents...');
        return loadAgentsForReport();
      }).then(() => {
        console.log('‚úÖ loadAgentsForReport termin√©, configuration des event listeners...');
        // After loading agents, set up event listeners
        initializeEventListeners();

        // If we have a selected agent and month, load the report
        console.log(`üîç V√©rification: dashboardAgentId=${dashboardAgentId}, dashboardMonthFilter=${dashboardMonthFilter}`);
        if (dashboardAgentId && dashboardMonthFilter) {
          setDashboardLocked(false);
          console.log('üìä Chargement du rapport mensuel...');
          loadMonthlyReport(dashboardMonthFilter, dashboardAgentId, {
            projectFilter: dashboardProjectFilter
          });
        } else {
          setDashboardLocked(true);
          console.log('‚è≥ Pas d\'agent ou de mois s√©lectionn√©, dashboard verrouill√©');
        }

        // Initial render
        renderDashboard();
        console.log('üéâ Initialisation du dashboard termin√©e!');
      }).catch(error => {
        console.error('‚ùå Error initializing dashboard:', error);
        setDashboardLocked(false);
        renderDashboard();
      });

      // Start motivation rotation
      startMotivationRotation();
    }

    async function loadAgentInfo(agentOverride = null) {
      try {
        console.log('Chargement des informations de l\'utilisateur...');
        let user = agentOverride;
        if (!user) {
          user = await getUserProfile();
        }

        if (!user) {
          console.error('Aucun utilisateur connect√©');
          return;
        }

        console.log('Donn√©es utilisateur r√©cup√©r√©es:', user);

        // Mettre √† jour l'avatar
        const avatar = document.getElementById('agent-avatar');
        if (avatar) {
          const firstName = user.first_name || '';
          const lastName = user.last_name || '';
          const initials = (firstName.charAt(0) + lastName.charAt(0)).toUpperCase();
          avatar.textContent = initials || user.email?.charAt(0).toUpperCase() || 'A';
        }

        // Mettre √† jour le nom
        const nameElement = document.getElementById('agent-name');
        if (nameElement) {
          // Essayer plusieurs champs possibles pour le nom
          const fullName = user.name ||
            [user.first_name, user.last_name].filter(Boolean).join(' ').trim() ||
            [user.firstName, user.lastName].filter(Boolean).join(' ').trim();

          if (fullName) {
            nameElement.textContent = fullName;
          } else if (user.email) {
            nameElement.textContent = user.email.split('@')[0];
          } else {
            nameElement.textContent = 'Utilisateur';
          }
        }

        // Mettre √† jour le r√¥le
        const roleElement = document.getElementById('agent-role');
        if (roleElement) {
          const roleNames = {
            'agent': 'Agent de Terrain',
            'superviseur': 'Superviseur',
            'admin': 'Administrateur',
            'superadmin': 'Super Administrateur'
          };

          const userRole = user.role || 'agent';
          roleElement.textContent = roleNames[userRole] || 'Utilisateur';
        }
      } catch (error) {
        console.error('Erreur lors du chargement des informations utilisateur:', error);

        // Afficher un message d'erreur √† l'utilisateur
        const nameElement = document.getElementById('agent-name');
        if (nameElement) {
          nameElement.textContent = 'Erreur de chargement';
        }

        const roleElement = document.getElementById('agent-role');
        if (roleElement) {
          roleElement.textContent = 'Veuillez rafra√Æchir la page';
        }
      }
    }

    function getCurrentAgentProject() {
      if (dashboardProjectFilter) {
        return dashboardProjectFilter;
      }

      const projectName = dashboardSelectedAgent?.project_name
        || dashboardSelectedAgent?.project
        || dashboardSelectedAgent?.projectName;
      return projectName ? projectName.trim() : null;
    }

    function renderDashboard() {
      window.agentDashboard.renderDashboard();
      // loadLeaderboard(); // D√©sactiv√© - le classement s'affiche dans le rapport mensuel
      const agentId = dashboardAgentId || window.agentDashboard?.getCurrentAgent()?.id;
      loadPerformanceStats(agentId);
      loadPresenceStats(agentId);
    }

    function setDashboardLocked(isLocked) {
      const content = document.getElementById('dashboard-content');
      const notice = document.getElementById('dashboard-locked-notice');
      if (!content || !notice) return;
      if (isLocked) {
        content.classList.add('d-none');
        notice.classList.remove('d-none');
      } else {
        content.classList.remove('d-none');
        notice.classList.add('d-none');
      }
    }

    function buildProjectActivityRanking(planifications = []) {
      if (!Array.isArray(planifications) || planifications.length === 0) {
        return [];
      }

      const statsByAgent = new Map();

      planifications.forEach(plan => {
        const rawAgentId = plan?.agent_id ?? plan?.user_id ?? plan?.userId ?? plan?.agentId;
        if (!rawAgentId && rawAgentId !== 0) return;
        const agentKey = String(rawAgentId);

        if (!statsByAgent.has(agentKey)) {
          const rawProjectName =
            plan?.project_name ||
            plan?.project ||
            plan?.agent?.project_name ||
            dashboardProjectFilter ||
            '';

          const nameCandidates = [
            plan?.agent?.name,
            `${plan?.agent?.first_name || ''} ${plan?.agent?.last_name || ''}`.trim(),
            `${plan?.first_name || ''} ${plan?.last_name || ''}`.trim(),
            plan?.agent?.email,
            plan?.email
          ].filter(Boolean);

          const agentName = nameCandidates[0] || `Agent ${agentKey}`;
          const projectKey = normalizeProjectIdentifier(rawProjectName);
          const projectName = formatProjectDisplay(rawProjectName);

          statsByAgent.set(agentKey, {
            agentId: agentKey,
            agentName,
            projectName,
            projectKey,
            total: 0,
            realized: 0,
            partially: 0,
            notRealized: 0,
            inProgress: 0
          });

          const knownName = getAgentDisplayNameById(agentKey);
          if (knownName) {
            statsByAgent.get(agentKey).agentName = knownName;
          }

          const knownProject = getAgentProjectNameById(agentKey);
          if (knownProject && knownProject !== 'Projet non attribu√©') {
            statsByAgent.get(agentKey).projectName = knownProject;
            statsByAgent.get(agentKey).projectKey = normalizeProjectIdentifier(knownProject);
          }
        }

        const agentStats = statsByAgent.get(agentKey);
        agentStats.total += 1;

        const status = detectActivityStatus(
          plan?.resultat_journee || plan?.status || plan?.result || ''
        );

        switch (status) {
          case 'realized':
            agentStats.realized += 1;
            break;
          case 'partiallyRealized':
            agentStats.partially += 1;
            break;
          case 'inProgress':
            agentStats.inProgress += 1;
            break;
          case 'notRealized':
          case 'planned':
          case 'unknown':
          default:
            agentStats.notRealized += 1;
            break;
        }
      });

      return [...statsByAgent.values()]
        .map(stats => {
          const displayProject = formatProjectDisplay(stats.projectName || dashboardProjectFilter || '');
          return {
            ...stats,
            projectName: displayProject,
            projectKey: stats.projectKey || normalizeProjectIdentifier(displayProject),
            agentName: stats.agentName || getAgentDisplayNameById(stats.agentId) || `Agent ${stats.agentId}`,
            tep: stats.total ? Math.round((stats.realized / stats.total) * 1000) / 10 : 0
          };
        })
        .sort((a, b) => {
          if (b.tep !== a.tep) return b.tep - a.tep;
          if (b.realized !== a.realized) return b.realized - a.realized;
          return a.agentName.localeCompare(b.agentName);
        });
    }

    // Construit le classement complet du projet pour le mois (Pr√©sence + TEP + Temps terrain)
    async function computeProjectRankingForMonth(projectName, monthRange, projectPlanifications = []) {
      console.log('üèÜ Calcul du classement pour:', projectName, monthRange);

      try {
        // 1) Partir des statistiques TEP calcul√©es √† partir des planifications
        const tepRanking = buildProjectActivityRanking(projectPlanifications);
        console.log(`üìä TEP Ranking calcul√©: ${tepRanking.length} agents avec des planifications`);

        // 2) R√©cup√©rer la liste des agents (depuis le s√©lecteur d√©j√† charg√©) correspondant au projet
        const allAgentOptions = Array.from(document.getElementById('report-agent-select')?.options || []);
        const candidates = allAgentOptions
          .map(opt => ({ id: Number(opt.value), name: opt.text, project: opt.dataset.project || '' }))
          .filter(a => a.id && (!projectName || (a.project || '').toLowerCase().includes(String(projectName).toLowerCase())));

        console.log(`üë• ${candidates.length} agents candidats pour le projet "${projectName}"`);

        if (candidates.length === 0) {
          console.warn('‚ö†Ô∏è Aucun agent trouv√© pour ce projet. Retour au classement TEP seul.');
          return tepRanking.map(entry => ({
            ...entry,
            presenceRate: 0,
            fieldTimeHours: 0,
            avgFieldTimePerDay: 0,
            workingDays: 22
          }));
        }

        // 3) Pour chaque agent, calculer pr√©sence et temps terrain √† partir des planifications (plus fiable que missions)
        const startIso = monthRange?.value?.split('/')?.[0] || monthRange?.start || monthRange?.from || '';
        const endIso = monthRange?.value?.split('/')?.[1] || monthRange?.end || monthRange?.to || '';

        if (!startIso || !endIso) {
          console.warn('‚ö†Ô∏è Dates de p√©riode invalides, utilisation du classement TEP seul');
          return tepRanking.map(entry => ({
            ...entry,
            presenceRate: 0,
            fieldTimeHours: 0,
            avgFieldTimePerDay: 0,
            workingDays: 22
          }));
        }

        const results = [];
        let successCount = 0;
        let errorCount = 0;

        // 3) Pour chaque agent du projet, calculer les indicateurs de performance
        for (const agent of allProjectAgents) {
          try {
            // R√©cup√©rer les planifications de l'agent pour le mois
            const planUrl = `/api/planifications?agent_id=${agent.id}&from=${encodeURIComponent(startIso.split('T')[0])}&to=${encodeURIComponent(endIso.split('T')[0])}&project_name=${encodeURIComponent(projectName || '')}`;
            const planResp = await fetch(planUrl, { headers: { 'Content-Type': 'application/json' }, signal: AbortSignal.timeout(10000) });
            const planJson = planResp.ok ? await planResp.json() : [];
            const planItems = Array.isArray(planJson)
              ? planJson
              : Array.isArray(planJson.items) ? planJson.items : Array.isArray(planJson.planifications) ? planJson.planifications : [];

            // Jours de pr√©sence bas√©s sur les planifications + temps terrain = dur√©e planifi√©e par jour
            const workedDaysSet = new Set();
            let totalFieldMinutes = 0;
            (planItems || []).forEach(p => {
              const dayStr = (p.date || p.date_planification || '').toString().slice(0, 10);
              if (dayStr) workedDaysSet.add(dayStr);
              const start = p.planned_start_time ? new Date(`2000-01-01T${p.planned_start_time}`) : null;
              const end = p.planned_end_time ? new Date(`2000-01-01T${p.planned_end_time}`) : null;
              if (start && end && end > start) {
                const diff = (end - start) / (1000 * 60);
                totalFieldMinutes += Math.min(diff, 14 * 60);
              }
            });

            const fieldTimeHours = Math.round((totalFieldMinutes / 60) * 10) / 10;
            const workingDays = countWorkingDays(new Date(startIso), new Date(endIso));
            const presenceRate = workingDays > 0 ? Math.round((workedDaysSet.size / workingDays) * 1000) / 10 : 0;

            // Associer TEP √† partir du ranking TEP existant
            const tepEntry = tepRanking.find(e => String(e.agentId) === String(agent.id));
            const tep = tepEntry ? Number(tepEntry.tep || 0) : 0;

            results.push({
              agentId: agent.id,
              agentName: agent.name,
              projectName: projectName,
              presenceRate,
              tep,
              fieldTimeHours,
              avgFieldTimePerDay: (workedDaysSet.size || 1) > 0 ? Math.round((fieldTimeHours / (workedDaysSet.size || 1)) * 10) / 10 : 0,
              workingDays,
              missionsCount: 0
            });
            successCount++;
          } catch (e) {
            console.warn(`‚ö†Ô∏è Erreur r√©cup√©ration planifications pour agent ${agent.id} (${agent.name}):`, e.message);
            errorCount++;

            // Ajouter l'agent avec donn√©es TEP uniquement
            const tepEntry = tepRanking.find(e => String(e.agentId) === String(agent.id));
            results.push({
              agentId: agent.id,
              agentName: agent.name,
              projectName: projectName,
              presenceRate: 0,
              tep: tepEntry ? Number(tepEntry.tep || 0) : 0,
              fieldTimeHours: 0,
              avgFieldTimePerDay: 0,
              workingDays: 22,
              missionsCount: 0
            });
          }
        }

        console.log(`‚úÖ Classement calcul√©: ${successCount} agents avec succ√®s, ${errorCount} erreurs`);
        console.log(`üìã Total agents dans le classement: ${results.length}`);

        return results;
      } catch (e) {
        console.error('‚ùå computeProjectRankingForMonth: erreur globale', e);
        // En cas d'erreur globale, retourner au moins le classement TEP
        const tepRanking = buildProjectActivityRanking(projectPlanifications);
        return tepRanking.map(entry => ({
          ...entry,
          presenceRate: 0,
          fieldTimeHours: 0,
          avgFieldTimePerDay: 0,
          workingDays: 22
        }));
      }
    }

    function buildFallbackLeaderboard(agents = []) {
      return agents.map(agent => ({
        id: agent.id,
        name: agent.name || `${agent.first_name || ''} ${agent.last_name || ''}`.trim() || agent.email || 'Agent',
        project: formatProjectDisplay(agent.project_name),
        score: 0,
        attendanceDays: 0,
        permissionDays: 0,
        checkins: 0,
        fieldTime: 0,
        presenceRate: 0,
        executionRate: 0,
        tep: 0,
        workingDays: 22
      }));
    }

    function renderLeaderboardTable() {
      const container = document.getElementById('leaderboard-container');
      if (!container) return;

      if (!leaderboardCache.length) {
        container.innerHTML = `
            <div class="alert alert-info">
              <i class="bi bi-info-circle me-2"></i>
              Aucune donn√©e de classement disponible pour le moment.
            </div>
          `;
        return;
      }

      const filterValue = leaderboardProjectFilter?.trim() || '';
      const normalizedFilter = normalizeProjectIdentifier(filterValue);
      const filteredEntries = normalizedFilter
        ? leaderboardCache.filter(entry => normalizeProjectIdentifier(formatProjectDisplay(entry.project)) === normalizedFilter)
        : leaderboardCache;

      // Calculer le score composite pour chaque agent
      // Score = 70% pr√©sence + 15% ex√©cution (TEP) + 15% temps terrain
      const calculateCompositeScore = (entry) => {
        const presenceRate = Number(entry.presenceRate || 0);
        const tepRate = Number(entry.executionRate || entry.tep || 0);
        const fieldTimeHours = Number(entry.fieldTime || 0);

        // Normaliser le temps terrain (max 8h par jour consid√©r√© comme 100%)
        const maxFieldTimePerDay = 8;
        const workingDays = Number(entry.workingDays || 22);
        const maxFieldTime = maxFieldTimePerDay * workingDays;
        const fieldTimeRate = maxFieldTime > 0 ? Math.min((fieldTimeHours / maxFieldTime) * 100, 100) : 0;

        return Math.round(((presenceRate * 0.70) + (tepRate * 0.15) + (fieldTimeRate * 0.15)) * 10) / 10;
      };

      // Enrichir les entr√©es avec le score composite et trier
      const enrichedEntries = filteredEntries.map(entry => ({
        ...entry,
        compositeScore: calculateCompositeScore(entry)
      })).sort((a, b) => b.compositeScore - a.compositeScore);

      const currentUserId = Number(dashboardAgentId || 0);

      // Formater les heures terrain
      const formatFieldTime = (hours) => {
        if (!hours || hours <= 0) return '0h';
        const h = Math.floor(hours);
        const m = Math.round((hours - h) * 60);
        return m > 0 ? `${h}h${String(m).padStart(2, '0')}` : `${h}h`;
      };

      // Badge de score selon la valeur
      const getScoreBadgeClass = (score) => {
        if (score >= 80) return 'bg-success';
        if (score >= 60) return 'bg-warning text-dark';
        return 'bg-danger';
      };

      const rows = enrichedEntries.map((entry, index) => {
        const isSelected = Number(entry.id) === currentUserId;
        const rank = index + 1;
        const rankBadge = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `#${rank}`;
        const presenceValue = Number(entry.presenceRate || 0);
        const presenceClass = presenceValue >= 80 ? 'text-success' : presenceValue >= 60 ? 'text-warning' : 'text-danger';
        const tepValue = Number(entry.executionRate || entry.tep || 0);
        const tepClass = tepValue >= 80 ? 'text-success' : tepValue >= 60 ? 'text-warning' : 'text-danger';
        const scoreValue = entry.compositeScore || 0;
        const scoreBadgeClass = getScoreBadgeClass(scoreValue);
        const fieldTime = formatFieldTime(entry.fieldTime);

        return `
            <tr class="${isSelected ? 'table-warning fw-bold' : ''}" ${isSelected ? 'style="background-color: #fff3cd !important; border-left: 4px solid #ffc107;"' : ''}>
              <td class="text-center fw-semibold fs-5">${rankBadge}</td>
              <td>
                <div class="fw-semibold">${escapeHtml(entry.name)}${isSelected ? ' <span class="badge bg-primary ms-1">Vous</span>' : ''}</div>
                <small class="text-muted">${formatProjectDisplay(entry.project)}</small>
              </td>
              <td class="text-center fw-semibold ${presenceClass}">${presenceValue.toFixed(1)}%</td>
              <td class="text-center fw-semibold ${tepClass}">${tepValue.toFixed(1)}%</td>
              <td class="text-center">${fieldTime}</td>
              <td class="text-center">
                <span class="badge ${scoreBadgeClass} fs-6">${scoreValue.toFixed(1)}</span>
              </td>
            </tr>
          `;
      }).join('');

      const projectOptions = leaderboardProjects.map(project => `
          <option value="${project}">${project}</option>
        `).join('');

      const leaderboardLegend = normalizedFilter
        ? `Classement restreint aux pairs du projet <strong>${escapeHtml(filterValue)}</strong>`
        : 'Score composite: 70% Pr√©sence + 15% Ex√©cution + 15% Terrain';

      container.innerHTML = `
          <div class="d-flex flex-wrap align-items-end gap-3 mb-3">
            <div>
              <label for="leaderboard-project-filter" class="form-label text-muted small mb-1">
                <i class="bi bi-filter-square me-1"></i>Projet
              </label>
              <select id="leaderboard-project-filter" class="form-select form-select-sm">
                <option value="">Tous les projets</option>
                ${projectOptions}
              </select>
            </div>
            <div class="ms-auto text-muted small">
              ${leaderboardLegend}
            </div>
          </div>
          <div class="table-responsive">
            <table class="table table-hover mb-0">
              <thead class="table-light">
                <tr>
                  <th style="width: 70px;" class="text-center">Rang</th>
                  <th>Nom & Pr√©nom</th>
                  <th class="text-center" title="Taux de pr√©sence (70% du score)">Pr√©sence</th>
                  <th class="text-center" title="Taux d'ex√©cution des planifications (15% du score)">TEP</th>
                  <th class="text-center" title="Temps pass√© sur le terrain (15% du score)">Terrain</th>
                  <th class="text-center" title="Score composite global">Score</th>
                </tr>
              </thead>
              <tbody>
                ${rows || `
                  <tr>
                    <td colspan="6" class="text-center py-4 text-muted">
                      Aucun agent trouv√© pour ce projet.
                    </td>
                  </tr>
                `}
              </tbody>
            </table>
          </div>
          <p class="text-muted small mb-0 mt-2">
            <i class="bi bi-info-circle me-1"></i>Score = 70% pr√©sence + 15% ex√©cution planification + 15% temps terrain
          </p>
        `;

      const select = document.getElementById('leaderboard-project-filter');
      if (select) {
        select.value = filterValue;
        select.addEventListener('change', event => {
          leaderboardProjectFilter = event.target.value || null;
          renderLeaderboardTable();
        });
      }
    }

    // Fonction pour charger le classement depuis l'API
    async function loadLeaderboard() {
      const container = document.getElementById('leaderboard-container');
      if (!container) return;

      container.innerHTML = `
          <div class="text-center py-4">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Chargement...</span>
            </div>
            <p class="mt-2 mb-0">Chargement du classement...</p>
          </div>
        `;

      try {
        const agentsResponse = await fetch('/api/admin/agents', {
          headers: { 'Content-Type': 'application/json' }
        });

        let agents = [];
        if (agentsResponse.ok) {
          const agentsData = await agentsResponse.json();
          agents = Array.isArray(agentsData) ? agentsData : (agentsData.data || []);
        }

        const filteredAgents = agents.filter(a =>
          (a.role === 'agent' || !a.role || a.role === 'AGENT') && a.id
        );

        let leaderboardData = [];
        try {
          const leaderboardResponse = await fetch('/api/agent/leaderboard', {
            headers: { 'Content-Type': 'application/json' }
          });
          if (leaderboardResponse.ok) {
            const leaderboardResult = await leaderboardResponse.json();
            if (leaderboardResult.success && Array.isArray(leaderboardResult.data)) {
              leaderboardData = leaderboardResult.data.map(item => ({
                id: item.agent_id || item.user_id || item.id,
                name: item.agent_name || item.name || 'Agent',
                project: formatProjectDisplay(item.project || item.project_name),
                score: item.score || 0,
                attendanceDays: item.attendanceDays || item.presenceDays || item.worked_days || 0,
                permissionDays: item.permissionDays || item.permission_days || 0,
                checkins: item.checkins || item.total_checkins || 0,
                fieldTime: item.fieldTime || item.field_time_hours || item.hours || 0,
                presenceRate: item.presenceRate || item.presence_rate || 0,
                executionRate: item.executionRate || item.execution_rate || item.tep || 0,
                tep: item.tep || item.executionRate || item.execution_rate || 0,
                workingDays: item.workingDays || item.working_days || 22
              }));
            }
          }
        } catch (error) {
          console.warn('Erreur r√©cup√©ration leaderboard (non critique):', error);
        }

        // Si pas de donn√©es du leaderboard API, calculer les statistiques pour chaque agent
        if (leaderboardData.length === 0 && filteredAgents.length > 0) {
          console.log('üîÑ Calcul des statistiques pour le classement...');
          leaderboardData = await calculateAgentsLeaderboardStats(filteredAgents);
        }

        if (leaderboardData.length === 0) {
          leaderboardData = buildFallbackLeaderboard(filteredAgents);
        }

        // Trier par score composite (sera calcul√© dans renderLeaderboardTable)
        leaderboardCache = leaderboardData;
        leaderboardProjects = [...new Set(leaderboardData.map(entry => formatProjectDisplay(entry.project)))]
          .filter(Boolean)
          .sort((a, b) => a.localeCompare(b));

        const preferredProject = getCurrentAgentProject();
        const preferredProjectFormatted = preferredProject ? formatProjectDisplay(preferredProject) : '';
        if (preferredProjectFormatted && !leaderboardProjects.includes(preferredProjectFormatted)) {
          leaderboardProjects = [...leaderboardProjects, preferredProjectFormatted]
            .filter(Boolean)
            .sort((a, b) => a.localeCompare(b));
        }
        const preferredInList = preferredProjectFormatted && leaderboardProjects.includes(preferredProjectFormatted) ? preferredProjectFormatted : '';

        if (!leaderboardProjectFilter) {
          leaderboardProjectFilter = preferredInList || '';
        } else if (leaderboardProjectFilter && leaderboardProjectFilter !== '' && !leaderboardProjects.includes(leaderboardProjectFilter)) {
          leaderboardProjectFilter = preferredInList || '';
        }

        renderLeaderboardTable();
      } catch (error) {
        console.error('Erreur lors du chargement du classement:', error);
        container.innerHTML = `
            <div class="alert alert-warning">
              <i class="bi bi-exclamation-triangle me-2"></i>
              Impossible de charger le classement. Veuillez r√©essayer plus tard.
            </div>
          `;
      }
    }

    // Calculer les statistiques de chaque agent pour le classement (bas√© sur MISSIONS)
    async function calculateAgentsLeaderboardStats(agents) {
      const results = [];
      const now = new Date();
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59);

      for (const agent of agents) {
        try {
          // R√©cup√©rer les MISSIONS de l'agent pour le mois en cours
          const missionsResponse = await fetch(
            `/api/missions?agent_id=${agent.id}&from=${startOfMonth.toISOString()}&to=${endOfMonth.toISOString()}`,
            { headers: { 'Content-Type': 'application/json' } }
          );

          let missions = [];
          if (missionsResponse.ok) {
            const missionsData = await missionsResponse.json();
            missions = Array.isArray(missionsData) ? missionsData : (missionsData.data || missionsData.missions || []);
          }

          // R√©cup√©rer les planifications de l'agent
          const planResponse = await fetch(
            `/api/planifications?user_id=${agent.id}&from=${startOfMonth.toISOString().split('T')[0]}&to=${endOfMonth.toISOString().split('T')[0]}`,
            { headers: { 'Content-Type': 'application/json' } }
          );

          let planifications = [];
          if (planResponse.ok) {
            const planData = await planResponse.json();
            planifications = Array.isArray(planData) ? planData : (planData.data || planData.planifications || []);
          }

          // Calculer les jours travaill√©s et le temps terrain √† partir des MISSIONS
          const workedDaysSet = new Set();
          let totalFieldTimeMinutes = 0;
          let missionsCount = 0;

          missions.forEach(mission => {
            const startTime = mission.start_time ? new Date(mission.start_time) : null;
            const endTime = mission.end_time ? new Date(mission.end_time) : null;
            const missionDate = mission.date_start ? new Date(mission.date_start) : startTime;

            if (missionDate && !isNaN(missionDate.getTime())) {
              const dayKey = missionDate.toISOString().split('T')[0];
              workedDaysSet.add(dayKey);
            }

            missionsCount++;

            // Calculer le temps terrain (start_time -> end_time)
            if (startTime && endTime && endTime > startTime) {
              const diffMinutes = (endTime - startTime) / (1000 * 60);
              totalFieldTimeMinutes += Math.min(diffMinutes, 14 * 60); // Max 14h par mission
            }
          });

          const fieldTimeHours = Math.round((totalFieldTimeMinutes / 60) * 10) / 10;
          const daysWithMissions = workedDaysSet.size || 1;
          const avgFieldTimePerDay = Math.round((fieldTimeHours / daysWithMissions) * 10) / 10;

          // Calculer les activit√©s r√©alis√©es
          const totalActivities = planifications.length;
          const realizedActivities = planifications.filter(p => {
            const result = String(p.resultat_journee || p.status || '').toLowerCase();
            return result.includes('r√©alis') || result.includes('realise') || result.includes('fait');
          }).length;

          // Calculer les taux
          const workingDays = countWorkingDays(startOfMonth, endOfMonth);
          const presenceRate = workingDays > 0 ? (workedDaysSet.size / workingDays) * 100 : 0;
          const executionRate = totalActivities > 0 ? (realizedActivities / totalActivities) * 100 : 0;

          results.push({
            id: agent.id,
            name: agent.name || `${agent.first_name || ''} ${agent.last_name || ''}`.trim() || 'Agent',
            project: formatProjectDisplay(agent.project_name),
            attendanceDays: workedDaysSet.size,
            workingDays,
            presenceRate: Math.round(presenceRate * 10) / 10,
            executionRate: Math.round(executionRate * 10) / 10,
            tep: Math.round(executionRate * 10) / 10,
            fieldTime: fieldTimeHours,
            avgFieldTimePerDay,
            missionsCount,
            totalActivities,
            realizedActivities
          });
        } catch (err) {
          console.warn(`Erreur calcul stats pour agent ${agent.id}:`, err);
          results.push({
            id: agent.id,
            name: agent.name || `${agent.first_name || ''} ${agent.last_name || ''}`.trim() || 'Agent',
            project: formatProjectDisplay(agent.project_name),
            presenceRate: 0,
            executionRate: 0,
            tep: 0,
            fieldTime: 0,
            avgFieldTimePerDay: 0,
            workingDays: 22
          });
        }
      }

      return results;
    }

    async function generateAiRecommendations() {
      if (aiGenerationInProgress) return;
      const monthValue = dashboardMonthValue || lastMonthlyReportParams.monthValue;
      const agentId = dashboardAgentId || lastMonthlyReportParams.agentId;

      if (!agentId || !monthValue) {
        alert('Veuillez s√©lectionner un agent et un mois avant de g√©n√©rer des recommandations IA.');
        return;
      }

      aiGenerationInProgress = true;
      try {
        await loadMonthlyReport(monthValue, agentId, { includeAI: true });
      } catch (error) {
        console.error('Erreur recommandation IA:', error);
        alert('Impossible de g√©n√©rer les recommandations IA pour le moment.');
      } finally {
        aiGenerationInProgress = false;
      }
    }

    // Fonction pour charger les statistiques de performance
    async function loadPerformanceStats(targetAgentId = dashboardAgentId) {
      const container = document.getElementById('performance-container');
      if (!container) return;

      try {
        const agentId = targetAgentId || window.agentDashboard?.getCurrentAgent()?.id;
        const missionsUrl = agentId ? `/api/me/missions?agent_id=${agentId}` : '/api/me/missions';
        const checkinsUrl = agentId ? `/api/checkins?user_id=${agentId}` : '/api/checkins';

        const missionsResponse = await fetch(missionsUrl, {
          headers: {
            'Content-Type': 'application/json'
          }
        });

        let missions = [];
        if (missionsResponse.ok) {
          const missionsData = await missionsResponse.json();
          missions = Array.isArray(missionsData) ? missionsData : (missionsData.missions || []);
        }

        const checkinsResponse = await fetch(checkinsUrl, {
          headers: {
            'Content-Type': 'application/json'
          }
        });

        let checkins = [];
        if (checkinsResponse.ok) {
          const checkinsData = await checkinsResponse.json();
          checkins = Array.isArray(checkinsData) ? checkinsData : (checkinsData.checkins || []);
        }

        // Calculer les statistiques
        const totalMissions = missions.length;
        const completedMissions = missions.filter(m => m.status === 'completed' || m.status === 'terminated').length;
        const pendingMissions = missions.filter(m => m.status === 'pending' || m.status === 'active').length;
        const completionRate = totalMissions > 0 ? Math.round((completedMissions / totalMissions) * 100) : 0;
        const totalCheckins = checkins.length;
        const avgCheckinsPerDay = totalCheckins > 0 ? (totalCheckins / 30).toFixed(1) : 0;

        const html = `
            <div class="table-responsive">
              <table class="stats-table">
                <thead>
                  <tr>
                    <th>Indicateur</th>
                    <th style="text-align: right;">Valeur</th>
                    <th style="text-align: center;">D√©tails</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="stat-label">Missions compl√©t√©es</td>
                    <td class="stat-value" style="text-align: right;">${completedMissions}</td>
                    <td style="text-align: center;">sur ${totalMissions} total</td>
                  </tr>
                  <tr>
                    <td class="stat-label">Taux de compl√©tion</td>
                    <td class="stat-value" style="text-align: right;">${completionRate}%</td>
                    <td style="text-align: center;">${pendingMissions} en cours</td>
                  </tr>
                  <tr>
                    <td class="stat-label">Total check-ins</td>
                    <td class="stat-value" style="text-align: right;">${totalCheckins}</td>
                    <td style="text-align: center;">${avgCheckinsPerDay} / jour (moy.)</td>
                  </tr>
                  <tr>
                    <td class="stat-label">Missions en attente</td>
                    <td class="stat-value" style="text-align: right;">${pendingMissions}</td>
                    <td style="text-align: center;">√Ä compl√©ter</td>
                  </tr>
                </tbody>
              </table>
            </div>
          `;

        container.innerHTML = html;
      } catch (error) {
        console.error('Erreur lors du chargement des performances:', error);
        container.innerHTML = `
            <div class="alert alert-warning">
              <i class="bi bi-exclamation-triangle me-2"></i>
              Impossible de charger les performances. Veuillez r√©essayer plus tard.
            </div>
          `;
      }
    }

    // Fonction pour charger les statistiques de pr√©sence
    async function loadPresenceStats(targetAgentId = dashboardAgentId) {
      const container = document.getElementById('stats-container');
      if (!container) return;

      try {
        // R√©cup√©rer les check-ins des 30 derniers jours
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(endDate.getDate() - 30);

        const userParam = targetAgentId ? `&user_id=${targetAgentId}` : '';
        const response = await fetch(`/api/checkins?from=${startDate.toISOString()}&to=${endDate.toISOString()}${userParam}`, {
          headers: {
            'Content-Type': 'application/json'
          }
        });

        let checkins = [];
        if (response.ok) {
          const data = await response.json();
          checkins = Array.isArray(data) ? data : (data.checkins || data.data || []);
        }

        // Calculer les statistiques
        const totalCheckins = checkins.length;
        const uniqueDays = new Set(checkins.map(c => {
          const date = new Date(c.timestamp || c.created_at);
          return date.toISOString().split('T')[0];
        })).size;

        const avgPerDay = uniqueDays > 0 ? (totalCheckins / uniqueDays).toFixed(1) : 0;
        const workingDays = 22; // Jours ouvr√©s moyens par mois
        const presenceRate = workingDays > 0 ? Math.round((uniqueDays / workingDays) * 1000) / 10 : 0;

        if (totalCheckins === 0 && checkins.length === 0) {
          container.innerHTML = `
              <div class="alert alert-info">
                <i class="bi bi-info-circle me-2"></i>
                Aucune donn√©e de pr√©sence disponible pour les 30 derniers jours.
              </div>
            `;
          return;
        }

        const html = `
            <div class="stats-grid-table">
              <div class="stat-card-table" style="border-left-color: #007bff;">
                <div class="stat-label">Total Check-ins</div>
                <div class="stat-value">${totalCheckins}</div>
                <div class="stat-change">30 derniers jours</div>
              </div>
              <div class="stat-card-table" style="border-left-color: #28a745;">
                <div class="stat-label">Jours avec activit√©</div>
                <div class="stat-value">${uniqueDays}</div>
                <div class="stat-change">${presenceRate}% de pr√©sence</div>
              </div>
              <div class="stat-card-table" style="border-left-color: #ffc107;">
                <div class="stat-label">Moyenne / jour</div>
                <div class="stat-value">${avgPerDay}</div>
                <div class="stat-change">check-ins quotidiens</div>
              </div>
            </div>
          `;

        container.innerHTML = html;
      } catch (error) {
        console.warn('Erreur lors du chargement des statistiques (non critique):', error);
        container.innerHTML = `
            <div class="alert alert-info">
              <i class="bi bi-info-circle me-2"></i>
              Les statistiques de pr√©sence seront disponibles une fois que vous aurez effectu√© des check-ins.
            </div>
          `;
      }
    }

    // La fonction setupEventListeners a √©t√© d√©plac√©e et unifi√©e avec initializeEventListeners

    function showBadgeCelebration(badge) {
      // Cr√©er une animation de c√©l√©bration pour le badge
      const celebration = document.createElement('div');
      celebration.className = 'badge-celebration';
      celebration.innerHTML = `
          <div class="celebration-content">
            <div class="celebration-icon">${badge.icon}</div>
            <div class="celebration-text">
              <h4>üèÜ Nouveau Badge!</h4>
              <p>${badge.name}</p>
            </div>
          </div>
        `;

      // Styles CSS pour l'animation
      celebration.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: linear-gradient(135deg, #ffc107, #ff9800);
          color: white;
          padding: 30px;
          border-radius: 20px;
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
          z-index: 10000;
          animation: badgeCelebration 3s ease-in-out;
        `;

      const style = document.createElement('style');
      style.textContent = `
          @keyframes badgeCelebration {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
          }
          .celebration-content {
            text-align: center;
          }
          .celebration-icon {
            font-size: 48px;
            margin-bottom: 15px;
          }
          .celebration-text h4 {
            margin: 0 0 10px 0;
            font-size: 24px;
          }
          .celebration-text p {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
          }
        `;
      document.head.appendChild(style);

      document.body.appendChild(celebration);

      // Supprimer apr√®s 3 secondes
      setTimeout(() => {
        if (document.body.contains(celebration)) {
          document.body.removeChild(celebration);
        }
      }, 3000);
    }

    function showAchievementNotification(achievement) {
      // Afficher une notification pour la nouvelle r√©alisation
      if (window.notificationManager) {
        window.notificationManager.sendNotification('üéâ Nouvelle R√©alisation!', {
          body: achievement.title,
          tag: 'achievement',
          requireInteraction: true
        });
      }
    }

    function startMotivationRotation() {
      const quoteElement = document.getElementById('motivation-quote');
      const authorElement = document.querySelector('.quote-author');
      
      if (!quoteElement) return;

      // Mettre √† jour la citation imm√©diatement
      const updateQuote = async () => {
        try {
          // Importer dynamiquement le module motivation
          const { getRandomQuote } = await import('/js/motivation.js');
          const quote = getRandomQuote();
          quoteElement.innerHTML = `
            <div class="quote-text">"${quote.text}"</div>
            <div class="quote-author">‚Äî ${quote.author}</div>
          `;
        } catch (error) {
          console.error('Erreur lors du chargement des citations:', error);
          quoteElement.innerHTML = '"La pers√©v√©rance est la cl√© du succ√®s."';
          if (authorElement) {
            authorElement.textContent = '‚Äî Proverbe';
          }
        }
      };

      // Mettre √† jour la citation toutes les 30 secondes
      setInterval(updateQuote, 30000);

      // Mettre √† jour imm√©diatement
      updateQuote();
    }

    // Fonction pour rafra√Æchir le tableau de bord
    function refreshDashboard() {
      window.agentDashboard.loadAgentData().then(() => {
        renderDashboard();
      });
    }

    // Exposer la fonction globalement
    window.refreshDashboard = refreshDashboard;

    // Gestionnaire pour les boutons de g√©n√©ration d'IA
    document.addEventListener('click', async function (e) {
      if (e.target.closest('.generate-ai-summary')) {
        e.preventDefault();
        const button = e.target.closest('.generate-ai-summary');
        const type = button.dataset.type || 'concise';

        // D√©sactiver le bouton pendant le chargement
        button.disabled = true;
        const originalContent = button.innerHTML;
        button.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>G√©n√©ration...';

        try {
          await generateAiSummary(type);
        } catch (error) {
          console.error('Erreur lors de la g√©n√©ration du r√©sum√©:', error);
          const container = document.querySelector('.ai-summary-container');
          if (container) {
            container.innerHTML = `
                    <div class="alert alert-danger mt-2">
                      <i class="bi bi-exclamation-triangle me-2"></i>
                      Erreur lors de la g√©n√©ration du r√©sum√©: ${error.message}
                    </div>
                  `;
          }
        } finally {
          // R√©activer le bouton
          button.disabled = false;
          button.innerHTML = originalContent;
        }
      }
    });

    // Fonction pour g√©n√©rer un r√©sum√© IA
    async function generateAiSummary(type = 'concise') {
      // Nettoyer les anciens √©couteurs et timers
      if (typeof cleanupTimers === 'function') {
        cleanupTimers();
      }

      const section = document.getElementById('ai-summary-section');
      if (!section) return;

      // Afficher l'indicateur de chargement
      const container = section.querySelector('.ai-summary-container');
      if (!container) return;

      container.innerHTML = `
              <div class="ai-loading">
                <div class="spinner-border text-primary mb-2" role="status">
                  <span class="visually-hidden">Chargement...</span>
                </div>
                <p class="mb-0">G√©n√©ration de l'analyse en cours...</p>
                <small class="text-muted">Veuillez patienter</small>
              </div>
            `;

      try {
        // R√©cup√©rer le jeton CSRF
        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content || '';

        // Pr√©parer les donn√©es pour l'API
        const requestData = {
          agentId: document.querySelector('[name="agent_id"]')?.value || '',
          month: document.querySelector('[name="month"]')?.value || '',
          type: type,
          _token: csrfToken,
          includeSuggestions: true
        };

        // Envoyer la requ√™te √† l'API
        const response = await fetch('/api/generate-ai-summary', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-TOKEN': csrfToken
          },
          body: JSON.stringify(requestData)
        });

        if (!response.ok) {
          throw new Error('Erreur lors de la g√©n√©ration du r√©sum√©');
        }

        const data = await response.json();

        if (data.success) {
          // Recharger le rapport pour afficher le nouveau r√©sum√©
          const monthSelect = document.querySelector('[name="month"]');
          const agentId = document.querySelector('[name="agent_id"]')?.value || '';
          loadMonthlyReport(
            monthSelect ? monthSelect.value : '',
            agentId,
            { includeAI: true }
          );
        } else {
          throw new Error(data.error || 'Erreur lors de la g√©n√©ration');
        }
      } catch (error) {
        console.error('Erreur lors de la g√©n√©ration du r√©sum√© IA:', error);
        const container = document.querySelector('.ai-summary-container');
        if (container) {
          container.innerHTML = `
                  <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    Erreur lors de la g√©n√©ration du r√©sum√©: ${error.message}
                  </div>
                `;
        }
      }
    }

    // Fonction pour formater le rapport en prompt pour le chatbot Hugging Face
    function formatReportForChatbot(report, meta, presenceData, activitiesData, agentCompositeScore, agentTepRate, presenceRateValue, agentFieldTimeHours, avgFieldTimePerDayValue, missionsCountValue, workingDaysValue, plannedTotal, realizedTotal, partiallyTotal, inProgressTotal, notRealizedTotal, selectedAgentEntry, selectedAgentRank, totalAgents) {
      const agentName = meta?.agent?.name || meta?.agent?.display_name || 'Agent';
      const period = meta?.month?.label || 'P√©riode';
      const projectName = meta?.agent?.project_name || report.projectRankingProject || 'Projet';
      
      const formatFieldTimeDisplay = (hours) => {
        if (!hours || hours === 0) return '0h';
        const h = Math.floor(hours);
        const m = Math.round((hours - h) * 60);
        return m > 0 ? `${h}h${String(m).padStart(2, '0')}` : `${h}h`;
      };
      
      const presenceInfo = `
Pr√©sence: ${presenceRateValue.toFixed(1)}% (${presenceData.workedDays || 0}/${workingDaysValue} jours ouvr√©s)
Check-ins total: ${presenceData.totalCheckins || 0}
Moyenne check-ins/jour: ${(presenceData.averageCheckinsPerDay || 0).toFixed(1)}
Jours permissionnaires: ${presenceData.permissionDays || 0}
`;
      
      const fieldTimeInfo = `
Temps pass√© sur le terrain: ${formatFieldTimeDisplay(agentFieldTimeHours)}
Moyenne par jour: ${formatFieldTimeDisplay(avgFieldTimePerDayValue)}
Nombre de missions: ${missionsCountValue}
`;
      
      const activitiesInfo = `
Activit√©s planifi√©es: ${plannedTotal}
Activit√©s r√©alis√©es: ${realizedTotal}
Activit√©s partiellement r√©alis√©es: ${partiallyTotal}
Activit√©s en cours: ${inProgressTotal}
Activit√©s non r√©alis√©es: ${notRealizedTotal}
Taux d'ex√©cution (TEP): ${agentTepRate.toFixed(1)}%
`;
      
      const performanceInfo = `
Score composite: ${agentCompositeScore.toFixed(1)}/100
- Pr√©sence: ${presenceRateValue.toFixed(1)}% (poids: 70%)
- TEP: ${agentTepRate.toFixed(1)}% (poids: 15%)
- Temps terrain: ${formatFieldTimeDisplay(agentFieldTimeHours)} (poids: 15%)
`;
      
      const rankingInfo = selectedAgentEntry && selectedAgentRank ? `
Classement dans l'√©quipe ${projectName}: ${selectedAgentEntry.displayRank}√®me sur ${totalAgents} agents
` : '';
      
      // Calculer des indicateurs suppl√©mentaires pour l'analyse
      const presenceScore = presenceRateValue >= 90 ? 'Excellent' : presenceRateValue >= 80 ? 'Bon' : presenceRateValue >= 70 ? 'Moyen' : presenceRateValue >= 50 ? 'Faible' : 'Critique';
      const tepScore = agentTepRate >= 90 ? 'Excellent' : agentTepRate >= 80 ? 'Bon' : agentTepRate >= 70 ? 'Moyen' : agentTepRate >= 50 ? 'Faible' : 'Critique';
      const fieldTimeScore = agentFieldTimeHours >= 100 ? 'Excellent' : agentFieldTimeHours >= 80 ? 'Bon' : agentFieldTimeHours >= 60 ? 'Moyen' : agentFieldTimeHours >= 40 ? 'Faible' : 'Insuffisant';
      
      // Analyser les √©carts
      const notRealizedPercentage = plannedTotal > 0 ? ((notRealizedTotal / plannedTotal) * 100).toFixed(1) : 0;
      const realizedPercentage = plannedTotal > 0 ? ((realizedTotal / plannedTotal) * 100).toFixed(1) : 0;
      
      return `Tu es un expert en analyse de performance et en coaching professionnel. Analyse en d√©tail le rapport mensuel de performance de l'agent ${agentName} pour la p√©riode ${period} dans le projet ${projectName}.

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üìä DONN√âES DU RAPPORT MENSUEL
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üë§ AGENT: ${agentName}
üìÖ P√âRIODE: ${period}
üè¢ PROJET: ${projectName}
${rankingInfo ? `üìä CLASSEMENT: ${selectedAgentEntry.displayRank}√®me sur ${totalAgents} agents\n` : ''}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìà INFORMATIONS DE PR√âSENCE
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
${presenceInfo}
Niveau: ${presenceScore} (${presenceRateValue >= 80 ? '‚úÖ Objectif atteint' : presenceRateValue >= 70 ? '‚ö†Ô∏è √Ä am√©liorer' : '‚ùå Action requise'})

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üåç TEMPS PASS√â SUR LE TERRAIN
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
${fieldTimeInfo}
Niveau: ${fieldTimeScore} (${agentFieldTimeHours >= 80 ? '‚úÖ Bon engagement terrain' : agentFieldTimeHours >= 60 ? '‚ö†Ô∏è Engagement moyen' : '‚ùå Engagement insuffisant'})

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚úÖ ACTIVIT√âS ET EX√âCUTION
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
${activitiesInfo}
Taux de r√©alisation: ${realizedPercentage}% (${realizedTotal}/${plannedTotal})
Taux de non-r√©alisation: ${notRealizedPercentage}% (${notRealizedTotal}/${plannedTotal})
Niveau TEP: ${tepScore} (${agentTepRate >= 80 ? '‚úÖ Bon taux d\'ex√©cution' : agentTepRate >= 60 ? '‚ö†Ô∏è Taux moyen' : '‚ùå Taux faible'})

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üéØ PERFORMANCE GLOBALE
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
${performanceInfo}
Score global: ${agentCompositeScore >= 90 ? 'üåü Excellent' : agentCompositeScore >= 80 ? '‚úÖ Bon' : agentCompositeScore >= 70 ? '‚ö†Ô∏è Moyen' : agentCompositeScore >= 60 ? 'üî∂ Faible' : '‚ùå Critique'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üìã INSTRUCTIONS D'ANALYSE
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Effectue une analyse approfondie et fournis une r√©ponse structur√©e avec les sections suivantes :

1Ô∏è‚É£ **POINTS FORTS** (3-5 points)
   - Identifie les aspects o√π l'agent excelle
   - Donne des exemples concrets bas√©s sur les donn√©es
   - Explique pourquoi ces points sont des forces

2Ô∏è‚É£ **POINTS √Ä AM√âLIORER** (3-5 points prioritaires)
   - Identifie les faiblesses ou opportunit√©s d'am√©lioration
   - Quantifie l'impact de chaque point sur la performance globale
   - Priorise les points les plus critiques

3Ô∏è‚É£ **ANALYSE D√âTAILL√âE PAR INDICATEUR**
   - Pr√©sence: Analyse la r√©gularit√©, les absences, les check-ins
   - Temps terrain: √âvalue l'engagement et la disponibilit√© sur le terrain
   - TEP: Analyse la capacit√© d'ex√©cution et de planification
   - Classement: Compare avec la moyenne de l'√©quipe si disponible

4Ô∏è‚É£ **RECOMMANDATIONS CONCR√àTES ET ACTIONNABLES** (minimum 5 recommandations)
   Pour chaque recommandation, pr√©cise :
   - L'objectif vis√©
   - L'action concr√®te √† entreprendre
   - Le r√©sultat attendu
   - Le d√©lai de mise en ≈ìuvre
   - Les indicateurs de suivi

5Ô∏è‚É£ **PLAN D'ACTION PRIORITAIRE** (Top 3 actions imm√©diates)
   - Les 3 actions les plus importantes √† mettre en place ce mois
   - Pour chaque action: Qui, Quoi, Quand, Comment

6Ô∏è‚É£ **OBJECTIFS POUR LE MOIS PROCHAIN**
   - Objectif de pr√©sence (en %)
   - Objectif de TEP (en %)
   - Objectif de temps terrain (en heures)
   - Objectif de score composite

7Ô∏è‚É£ **MESSAGES DE MOTIVATION ET ENCOURAGEMENT**
   - Un message personnalis√© pour encourager l'agent
   - Reconnaissance des efforts et des r√©sultats obtenus

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üìä GUIDE D'INTERPR√âTATION DES INDICATEURS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Pour aider √† l'interpr√©tation, voici les r√©f√©rences et seuils √† utiliser :

**PR√âSENCE (Poids: 70% du score composite)**
- Excellent (‚â•90%) : Assiduit√© remarquable, tr√®s fiable
- Bon (80-89%) : Bonne assiduit√©, quelques absences justifi√©es
- Moyen (70-79%) : Assiduit√© acceptable mais √† am√©liorer
- Faible (50-69%) : Trop d'absences, action corrective n√©cessaire
- Critique (<50%) : Situation pr√©occupante, intervention urgente requise

**TEP - TAUX D'EX√âCUTION DES PLANIFICATIONS (Poids: 15%)**
- Excellent (‚â•90%) : Excellente capacit√© d'ex√©cution, planification r√©aliste
- Bon (80-89%) : Bon taux d'ex√©cution, planification g√©n√©ralement adapt√©e
- Moyen (70-79%) : Taux moyen, possible sur-planification ou difficult√©s d'ex√©cution
- Faible (50-69%) : Difficult√©s √† ex√©cuter les planifications, r√©vision n√©cessaire
- Critique (<50%) : Probl√®me majeur d'ex√©cution, analyse approfondie requise

**TEMPS TERRAIN (Poids: 15% du score composite)**
- Excellent (‚â•100h/mois) : Engagement terrain tr√®s √©lev√©, disponibilit√© maximale
- Bon (80-99h) : Bon engagement terrain, pr√©sence r√©guli√®re sur le terrain
- Moyen (60-79h) : Engagement moyen, peut √™tre am√©lior√©
- Faible (40-59h) : Engagement insuffisant, besoin d'augmenter le temps terrain
- Insuffisant (<40h) : Tr√®s faible pr√©sence terrain, action prioritaire

**SCORE COMPOSITE (Moyenne pond√©r√©e)**
- Excellent (‚â•90) : Performance globale remarquable, agent mod√®le
- Bon (80-89) : Bonne performance globale, quelques axes d'am√©lioration
- Moyen (70-79) : Performance acceptable mais n√©cessite des am√©liorations
- Faible (60-69) : Performance insuffisante, plan d'action n√©cessaire
- Critique (<60) : Performance pr√©occupante, accompagnement intensif requis

**INTERPR√âTATION DES CORR√âLATIONS**
- Pr√©sence √©lev√©e + TEP √©lev√© = Agent tr√®s performant et fiable
- Pr√©sence √©lev√©e + TEP faible = Possible sur-planification ou difficult√©s d'organisation
- Pr√©sence faible + TEP √©lev√© = Agent efficace mais assiduit√© √† am√©liorer
- Temps terrain √©lev√© + TEP faible = Possible dispersion ou activit√©s non planifi√©es
- Temps terrain faible + TEP √©lev√© = Efficacit√© mais engagement terrain √† renforcer

**ANALYSE DES ACTIVIT√âS NON R√âALIS√âES**
- Si activit√©s non r√©alis√©es > 20% du total : Probl√®me de planification ou de capacit√©
- Si activit√©s partiellement r√©alis√©es √©lev√©es : Besoin de mieux d√©finir les objectifs
- Si activit√©s en cours nombreuses : Possible surcharge ou manque de cl√¥ture

**CONTEXTE DU CLASSEMENT**
- Si classement dans le top 25% : Performance sup√©rieure √† la moyenne de l'√©quipe
- Si classement dans la moyenne (25-75%) : Performance align√©e avec l'√©quipe
- Si classement dans le bas 25% : Performance inf√©rieure, besoin d'accompagnement

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ö†Ô∏è IMPORTANT
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

- Sois sp√©cifique et concret dans tes recommandations
- Base-toi uniquement sur les donn√©es fournies
- Utilise les seuils et r√©f√©rences ci-dessus pour interpr√©ter les indicateurs
- Propose des actions r√©alisables et mesurables
- Adapte le ton selon le niveau de performance (encourageant pour les bons r√©sultats, constructif pour les points √† am√©liorer)
- Si le classement est disponible, utilise-le pour contextualiser la performance
- Identifie les corr√©lations entre les diff√©rents indicateurs (ex: temps terrain vs TEP)
- Explique clairement ce que signifient les graphiques et indicateurs pour l'agent

Commence ton analyse maintenant.`;
    }

    // Fonction pour copier le prompt du rapport
    function copyReportPrompt() {
      // Pr√©parer le prompt avec les donn√©es du rapport stock√©es
      const reportData = window.lastMonthlyReportData || {};
      const meta = reportData.meta || {};
      const presenceData = window.lastPresenceData || reportData.presence || {};
      const activitiesData = window.lastActivitiesData || reportData.activities || {};
      
      // R√©cup√©rer les valeurs stock√©es
      const agentCompositeScore = window.lastAgentCompositeScore || 0;
      const agentTepRate = window.lastAgentTepRate || activitiesData?.performance?.executionRate || 0;
      const presenceRateValue = window.lastPresenceRateValue || Number(presenceData.presenceRate || 0);
      const agentFieldTimeHours = window.lastAgentFieldTimeHours || 0;
      const avgFieldTimePerDayValue = window.lastAvgFieldTimePerDay || 0;
      const missionsCountValue = presenceData.missionsCount || 0;
      const workingDaysValue = window.lastWorkingDaysValue || Number(presenceData.workingDays || 22);
      const plannedTotal = window.lastPlannedTotal || activitiesData?.total || 0;
      const realizedTotal = window.lastRealizedTotal || activitiesData?.breakdown?.find(b => b.key === 'realized')?.count || 0;
      const partiallyTotal = window.lastPartiallyTotal || activitiesData?.breakdown?.find(b => b.key === 'partiallyRealized')?.count || 0;
      const inProgressTotal = window.lastInProgressTotal || activitiesData?.breakdown?.find(b => b.key === 'inProgress')?.count || 0;
      const notRealizedTotal = window.lastNotRealizedTotal || activitiesData?.breakdown?.find(b => b.key === 'notRealized')?.count || 0;
      const selectedAgentEntry = window.lastSelectedAgentEntry || null;
      const selectedAgentRank = window.lastSelectedAgentRank || null;
      const totalAgents = window.lastTotalAgents || reportData.projectRanking?.length || 0;
      
      const prompt = formatReportForChatbot(
        reportData, meta, presenceData, activitiesData,
        agentCompositeScore, agentTepRate, presenceRateValue,
        agentFieldTimeHours, avgFieldTimePerDayValue, missionsCountValue,
        workingDaysValue, plannedTotal, realizedTotal, partiallyTotal,
        inProgressTotal, notRealizedTotal, selectedAgentEntry,
        selectedAgentRank, totalAgents
      );
      
      // Stocker le prompt
      window.lastReportPrompt = prompt;
      
      navigator.clipboard.writeText(prompt).then(() => {
        alert('‚úÖ Rapport copi√© dans le presse-papiers !\n\nVous pouvez maintenant le coller dans WhatsApp.');
      }).catch(err => {
        console.error('Erreur lors de la copie:', err);
        // Fallback: cr√©er un textarea temporaire
        const textarea = document.createElement('textarea');
        textarea.value = prompt;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        alert('‚úÖ Rapport copi√© dans le presse-papiers !');
      });
    }

    // Fonction pour ouvrir WhatsApp avec ChatGPT
    function openChatGPTWhatsApp() {
      // Pr√©parer le prompt avec les donn√©es du rapport stock√©es
      const reportData = window.lastMonthlyReportData || {};
      const meta = reportData.meta || {};
      const presenceData = window.lastPresenceData || reportData.presence || {};
      const activitiesData = window.lastActivitiesData || reportData.activities || {};
      
      // R√©cup√©rer les valeurs stock√©es
      const agentCompositeScore = window.lastAgentCompositeScore || 0;
      const agentTepRate = window.lastAgentTepRate || activitiesData?.performance?.executionRate || 0;
      const presenceRateValue = window.lastPresenceRateValue || Number(presenceData.presenceRate || 0);
      const agentFieldTimeHours = window.lastAgentFieldTimeHours || 0;
      const avgFieldTimePerDayValue = window.lastAvgFieldTimePerDay || 0;
      const missionsCountValue = presenceData.missionsCount || 0;
      const workingDaysValue = window.lastWorkingDaysValue || Number(presenceData.workingDays || 22);
      const plannedTotal = window.lastPlannedTotal || activitiesData?.total || 0;
      const realizedTotal = window.lastRealizedTotal || activitiesData?.breakdown?.find(b => b.key === 'realized')?.count || 0;
      const partiallyTotal = window.lastPartiallyTotal || activitiesData?.breakdown?.find(b => b.key === 'partiallyRealized')?.count || 0;
      const inProgressTotal = window.lastInProgressTotal || activitiesData?.breakdown?.find(b => b.key === 'inProgress')?.count || 0;
      const notRealizedTotal = window.lastNotRealizedTotal || activitiesData?.breakdown?.find(b => b.key === 'notRealized')?.count || 0;
      const selectedAgentEntry = window.lastSelectedAgentEntry || null;
      const selectedAgentRank = window.lastSelectedAgentRank || null;
      const totalAgents = window.lastTotalAgents || reportData.projectRanking?.length || 0;
      
      const prompt = formatReportForChatbot(
        reportData, meta, presenceData, activitiesData,
        agentCompositeScore, agentTepRate, presenceRateValue,
        agentFieldTimeHours, avgFieldTimePerDayValue, missionsCountValue,
        workingDaysValue, plannedTotal, realizedTotal, partiallyTotal,
        inProgressTotal, notRealizedTotal, selectedAgentEntry,
        selectedAgentRank, totalAgents
      );
      
      // Stocker le prompt
      window.lastReportPrompt = prompt;
      
      // Pr√©parer le message complet
      const fullMessage = 'Bonjour, j\'aimerais avoir une interpr√©tation et des recommandations pour mon rapport mensuel. Voici les donn√©es :\n\n' + prompt;
      
      // Num√©ro ChatGPT WhatsApp : +1 (800) 242-8478
      // Format pour WhatsApp : 18002428478 (sans le + et les espaces/parenth√®ses)
      const chatGPTPhoneNumber = '18002428478';
      
      // D√©tecter si on est sur mobile ou desktop
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      
      // URL WhatsApp (sans message pr√©-rempli, l'utilisateur collera le rapport)
      let whatsappUrl;
      if (isMobile) {
        whatsappUrl = `https://wa.me/${chatGPTPhoneNumber}`;
      } else {
        whatsappUrl = `https://web.whatsapp.com/send?phone=${chatGPTPhoneNumber}`;
      }
      
      // Copier le rapport complet dans le presse-papiers
      navigator.clipboard.writeText(fullMessage).then(() => {
        console.log('‚úÖ Rapport copi√© dans le presse-papiers');
        
        // Ouvrir WhatsApp
        const whatsappWindow = window.open(whatsappUrl, '_blank');
        
        if (whatsappWindow) {
          // Afficher une notification
          setTimeout(() => {
            alert('‚úÖ WhatsApp s\'ouvre avec ChatGPT !\n\n' +
                  'Le rapport a √©t√© copi√© dans votre presse-papiers.\n\n' +
                  'Instructions :\n' +
                  '1. Collez le rapport (Ctrl+V ou Cmd+V) dans le chat\n' +
                  '2. Envoyez le message\n' +
                  '3. ChatGPT vous r√©pondra avec une interpr√©tation et des recommandations\n\n' +
                  'Num√©ro ChatGPT : +1 (800) 242-8478');
          }, 500);
        } else {
          // Si la popup est bloqu√©e
          alert('‚ö†Ô∏è La popup a √©t√© bloqu√©e par votre navigateur.\n\n' +
                'Le rapport a √©t√© copi√© dans votre presse-papiers.\n\n' +
                'Instructions :\n' +
                '1. Ouvrez WhatsApp (sur votre t√©l√©phone ou web.whatsapp.com)\n' +
                '2. Envoyez un message au num√©ro : +1 (800) 242-8478\n' +
                '3. Collez le rapport (Ctrl+V ou Cmd+V) dans votre message\n' +
                '4. Envoyez le message\n\n' +
                `Ou cliquez sur ce lien :\nhttps://wa.me/${chatGPTPhoneNumber}`);
        }
      }).catch(err => {
        console.error('Erreur lors de la copie:', err);
        // Ouvrir WhatsApp quand m√™me
        const whatsappWindow = window.open(whatsappUrl, '_blank');
        alert('‚ö†Ô∏è Impossible de copier automatiquement dans le presse-papiers.\n\n' +
              'Veuillez utiliser le bouton "Copier le rapport" pour copier manuellement le rapport.\n\n' +
              'Num√©ro ChatGPT : +1 (800) 242-8478');
      });
      
      console.log('üì± Ouverture de WhatsApp avec ChatGPT:', {
        phoneNumber: chatGPTPhoneNumber,
        isMobile: isMobile,
        promptLength: prompt.length
      });
    }

    // Fonction pour ouvrir Gemini Chat
    function openGeminiChat() {
      // Pr√©parer le prompt avec les donn√©es du rapport stock√©es
      const reportData = window.lastMonthlyReportData || {};
      const meta = reportData.meta || {};
      const presenceData = window.lastPresenceData || reportData.presence || {};
      const activitiesData = window.lastActivitiesData || reportData.activities || {};
      
      // R√©cup√©rer les valeurs stock√©es
      const agentCompositeScore = window.lastAgentCompositeScore || 0;
      const agentTepRate = window.lastAgentTepRate || activitiesData?.performance?.executionRate || 0;
      const presenceRateValue = window.lastPresenceRateValue || Number(presenceData.presenceRate || 0);
      const agentFieldTimeHours = window.lastAgentFieldTimeHours || 0;
      const avgFieldTimePerDayValue = window.lastAvgFieldTimePerDay || 0;
      const missionsCountValue = presenceData.missionsCount || 0;
      const workingDaysValue = window.lastWorkingDaysValue || Number(presenceData.workingDays || 22);
      const plannedTotal = window.lastPlannedTotal || activitiesData?.total || 0;
      const realizedTotal = window.lastRealizedTotal || activitiesData?.breakdown?.find(b => b.key === 'realized')?.count || 0;
      const partiallyTotal = window.lastPartiallyTotal || activitiesData?.breakdown?.find(b => b.key === 'partiallyRealized')?.count || 0;
      const inProgressTotal = window.lastInProgressTotal || activitiesData?.breakdown?.find(b => b.key === 'inProgress')?.count || 0;
      const notRealizedTotal = window.lastNotRealizedTotal || activitiesData?.breakdown?.find(b => b.key === 'notRealized')?.count || 0;
      const selectedAgentEntry = window.lastSelectedAgentEntry || null;
      const selectedAgentRank = window.lastSelectedAgentRank || null;
      const totalAgents = window.lastTotalAgents || reportData.projectRanking?.length || 0;
      
      const prompt = formatReportForChatbot(
        reportData, meta, presenceData, activitiesData,
        agentCompositeScore, agentTepRate, presenceRateValue,
        agentFieldTimeHours, avgFieldTimePerDayValue, missionsCountValue,
        workingDaysValue, plannedTotal, realizedTotal, partiallyTotal,
        inProgressTotal, notRealizedTotal, selectedAgentEntry,
        selectedAgentRank, totalAgents
      );
      
      // Stocker le prompt
      window.lastReportPrompt = prompt;
      
      // Pr√©parer le message complet
      const fullMessage = 'Bonjour, j\'aimerais avoir une interpr√©tation et des recommandations pour mon rapport mensuel. Voici les donn√©es :\n\n' + prompt;
      
      // URL Gemini Chat
      const geminiUrl = 'https://gemini.google.com/app?hl=fr';
      
      // Copier le rapport complet dans le presse-papiers
      navigator.clipboard.writeText(fullMessage).then(() => {
        console.log('‚úÖ Rapport copi√© dans le presse-papiers');
        
        // Ouvrir Gemini Chat
        const geminiWindow = window.open(geminiUrl, '_blank');
        
        if (geminiWindow) {
          // Afficher une notification
          setTimeout(() => {
            alert('‚úÖ Gemini Chat s\'ouvre !\n\n' +
                  'Le rapport a √©t√© copi√© dans votre presse-papiers.\n\n' +
                  'Instructions :\n' +
                  '1. Collez le rapport (Ctrl+V ou Cmd+V) dans le chat Gemini\n' +
                  '2. Envoyez le message\n' +
                  '3. Gemini vous r√©pondra avec une interpr√©tation et des recommandations');
          }, 500);
        } else {
          // Si la popup est bloqu√©e
          alert('‚ö†Ô∏è La popup a √©t√© bloqu√©e par votre navigateur.\n\n' +
                'Le rapport a √©t√© copi√© dans votre presse-papiers.\n\n' +
                'Instructions :\n' +
                '1. Ouvrez Gemini Chat : https://gemini.google.com/app?hl=fr\n' +
                '2. Collez le rapport (Ctrl+V ou Cmd+V) dans le chat\n' +
                '3. Envoyez le message');
        }
      }).catch(err => {
        console.error('Erreur lors de la copie:', err);
        // Ouvrir Gemini quand m√™me
        const geminiWindow = window.open(geminiUrl, '_blank');
        alert('‚ö†Ô∏è Impossible de copier automatiquement dans le presse-papiers.\n\n' +
              'Veuillez utiliser le bouton "Copier le rapport" pour copier manuellement le rapport.\n\n' +
              'Gemini Chat : https://gemini.google.com/app?hl=fr');
      });
      
      console.log('ü§ñ Ouverture de Gemini Chat:', {
        promptLength: prompt.length
      });
    }

    // Exposer les fonctions globalement
    window.copyReportPrompt = copyReportPrompt;
    window.openChatGPTWhatsApp = openChatGPTWhatsApp;
    window.openGeminiChat = openGeminiChat;

    // Fonction pour obtenir l'ID utilisateur depuis l'API
    async function getUserId() {
      try {
        const response = await fetch('/api/profile', {
          headers: {
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`Erreur ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();

        // L'API peut retourner { success: true, user: {...} } ou directement {...}
        const profile = data.user || data;

        // V√©rifier plusieurs champs possibles pour l'ID
        const userId = profile?.id || profile?.user_id || profile?.userId;

        if (userId) {
          return userId;
        }

        throw new Error('ID utilisateur introuvable dans le profil');
      } catch (e) {
        console.error('Erreur lors de la r√©cup√©ration de l\'ID utilisateur:', e);
        throw new Error('Impossible de r√©cup√©rer l\'ID utilisateur');
      }
    }

    // Fonction pour charger la liste des agents pour le s√©lecteur
    /**
     * Charge la liste des agents et des superviseurs pour le filtre
     */
    async function loadAgentsForReport() {
      console.log('üîÑ Chargement de la liste des agents et superviseurs...');
      const select = document.getElementById('report-agent-select');
      if (!select) {
        console.error('‚ùå √âl√©ment select des agents non trouv√©');
        return;
      }

      try {
        // Afficher un indicateur de chargement
        select.innerHTML = '<option value="">Chargement des utilisateurs...</option>';
        console.log('üìù Select initialis√© avec "Chargement..."');

        // R√©cup√©rer le profil de l'utilisateur connect√©
        const user = await getUserProfile();
        console.log('Profil utilisateur charg√©:', user);

        // D√©terminer le r√¥le et les permissions
        const userRole = (user?.role || user?.user?.role || 'agent').toLowerCase();
        const isAdmin = ['admin', 'administrateur'].includes(userRole);
        const isSupervisor = isAdmin || ['superviseur', 'supervisor'].includes(userRole);
        const currentUserId = user?.id || user?.user_id || await getUserId();

        console.log(`Utilisateur: ID=${currentUserId}, R√¥le=${userRole}, Admin=${isAdmin}, Superviseur=${isSupervisor}`);

        // Cr√©er l'entr√©e de l'utilisateur courant
        const currentUserEntry = {
          id: Number(currentUserId),
          name: user?.name || [user?.first_name, user?.last_name].filter(Boolean).join(' ').trim() || user?.email || 'Moi',
          first_name: user?.first_name,
          last_name: user?.last_name,
          email: user?.email,
          role: userRole,
          project: user?.project,
          project_name: formatProjectDisplay(user?.project_name || user?.project || 'Projet non attribu√©')
        };

        // Si l'utilisateur n'est ni admin ni superviseur, il ne peut voir que son propre profil
        if (!isAdmin && !isSupervisor) {
          console.log('Utilisateur standard, chargement du profil utilisateur uniquement');
          dashboardAgents = [currentUserEntry];
          dashboardAgentId = String(currentUserId);
          dashboardSelectedAgent = currentUserEntry;
          select.innerHTML = `<option value="${currentUserId}">Moi</option>`;
          select.value = currentUserId;

          populateProjectFilterOptions(dashboardAgents);
          syncProjectSelectWithAgent(currentUserEntry, { force: true });
          return;
        }

        console.log('Chargement de la liste compl√®te des utilisateurs...');

        // R√©cup√©rer tous les utilisateurs (agents et superviseurs)
        const token = localStorage.getItem('jwt');
        if (!token) {
          console.error('No JWT token found in localStorage');
          throw new Error('Non authentifi√©. Veuillez vous reconnecter.');
        }

        console.log('üåê Fetching agents from /api/agents with token:', token.substring(0, 10) + '...');

        let agents = [];

        try {
          console.log('üì° Envoi de la requ√™te √† /api/agents...');
          const response = await fetch('/api/agents', {
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`,
              'Cache-Control': 'no-cache',
              'Pragma': 'no-cache'
            },
            cache: 'no-store'
          });

          console.log(`üì• R√©ponse re√ßue: status=${response.status}, ok=${response.ok}`);

          if (!response.ok) {
            const errorText = await response.text();
            console.error(`‚ùå API Error: ${response.status} - ${errorText}`);
            // En cas d'erreur 401 ou 403, forcer une d√©connexion
            if (response.status === 401 || response.status === 403) {
              console.error('Session expir√©e ou non autoris√©e, d√©connexion...');
              localStorage.removeItem('jwt');
              window.location.href = '/login.html?session_expired=1';
              return [currentUserEntry];
            }
            throw new Error(`Erreur lors de la r√©cup√©ration des agents: ${response.status} - ${errorText}`);
          }

          const responseData = await response.json();
          console.log(`üì¶ API Response: ${responseData?.length || 0} utilisateurs r√©cup√©r√©s`);
          console.log('üìã Donn√©es brutes:', responseData);

          if (!Array.isArray(responseData)) {
            console.error('‚ùå Expected an array of agents but got:', typeof responseData, responseData);
            throw new Error('Format de r√©ponse inattendu du serveur');
          }

          if (responseData.length > 0) {
            console.log(`üë§ Premier agent re√ßu:`, responseData[0]);
          }

          agents = responseData;

        } catch (error) {
          console.error('Erreur lors de la r√©cup√©ration des agents:', error);
          // En cas d'erreur, utiliser uniquement l'utilisateur courant
          agents = [];
        }

        // S'assurer que les agents sont un tableau valide
        if (!Array.isArray(agents) || agents.length === 0) {
          console.warn('Aucun utilisateur trouv√© dans la r√©ponse ou format invalide, utilisation de l\'utilisateur courant uniquement');
          agents = [];
        }

        // Formater les agents pour s'assurer que les champs n√©cessaires existent
        agents = agents.map(agent => {
          const formattedAgent = {
            id: Number(agent.id) || 0,
            name: agent.name || [agent.first_name, agent.last_name].filter(Boolean).join(' ').trim() || agent.email || `Utilisateur ${agent.id}`,
            first_name: agent.first_name || '',
            last_name: agent.last_name || '',
            email: agent.email || '',
            role: (agent.role || 'agent').toLowerCase(),
            project: agent.project || '',
            project_name: formatProjectDisplay(agent.project_name || agent.project || 'Projet non attribu√©')
          };
          console.log(`‚úÖ Agent format√©: ID=${formattedAgent.id}, Name="${formattedAgent.name}", Email="${formattedAgent.email}", Project="${formattedAgent.project_name}"`);
          return formattedAgent;
        });

        console.log(`üìä Total agents format√©s: ${agents.length}`);

        // Si aucun agent n'a √©t√© r√©cup√©r√©, ajouter au moins l'utilisateur courant
        if (agents.length === 0) {
          console.warn('‚ö†Ô∏è Aucun agent r√©cup√©r√©, ajout de l\'utilisateur courant');
          agents = [currentUserEntry];
        }

        // Filtrer les utilisateurs selon le r√¥le de l'utilisateur connect√©
        let filteredAgents = [];

        if (isAdmin) {
          // Les administrateurs voient tout le monde
          filteredAgents = [...agents];
        } else if (isSupervisor) {
          // Les superviseurs voient les agents et eux-m√™mes
          filteredAgents = agents.filter(a =>
            (a.role === 'agent' || a.role === 'superviseur' || a.role === 'supervisor') ||
            a.id === currentUserId
          );

          // S'assurer que le superviseur se voit lui-m√™me
          if (!filteredAgents.some(a => a.id === currentUserId)) {
            filteredAgents.push({
              ...currentUserEntry,
              id: Number(currentUserEntry.id)
            });
          }
        } else {
          // Les utilisateurs normaux ne voient qu'eux-m√™mes
          filteredAgents = [{
            ...currentUserEntry,
            id: Number(currentUserEntry.id)
          }];
        }

        // S'assurer que les ID sont des nombres
        filteredAgents = filteredAgents.map(agent => ({
          ...agent,
          id: Number(agent.id),
          // S'assurer que le r√¥le est en minuscules
          role: (agent.role || 'agent').toLowerCase()
        }));

        // Trier les agents : d'abord les superviseurs, puis les agents, par ordre alphab√©tique
        filteredAgents.sort((a, b) => {
          // L'utilisateur actuel en premier
          if (a.id === currentUserId) return -1;
          if (b.id === currentUserId) return 1;

          // Ensuite les administrateurs
          if (a.role === 'admin' && b.role !== 'admin') return -1;
          if (a.role !== 'admin' && b.role === 'admin') return 1;

          // Puis les superviseurs
          if ((a.role === 'superviseur' || a.role === 'supervisor') &&
            !['superviseur', 'supervisor', 'admin'].includes(b.role)) return -1;
          if (!['superviseur', 'supervisor', 'admin'].includes(a.role) &&
            (b.role === 'superviseur' || b.role === 'supervisor')) return 1;

          // Enfin trier par nom
          const nameA = (a.name || `${a.first_name || ''} ${a.last_name || ''}`).trim().toLowerCase();
          const nameB = (b.name || `${b.first_name || ''} ${b.last_name || ''}`).trim().toLowerCase();
          return nameA.localeCompare(nameB, 'fr', { sensitivity: 'base' });
        });

        // Mettre √† jour la liste des agents dans le tableau de bord
        dashboardAgents = filteredAgents;

        // Mettre √† jour la liste d√©roulante
        let options = [];

        // Ajouter l'utilisateur actuel en premier
        const currentUser = filteredAgents.find(a => a.id === currentUserId) || currentUserEntry;
        options.push(`<option value="${currentUserId}">Moi${isAdmin ? ' (Admin)' : isSupervisor ? ' (Superviseur)' : ''}</option>`);

        // Ajouter les autres utilisateurs
        filteredAgents.forEach(agent => {
          if (agent.id !== currentUserId) {
            // Construire le nom de l'agent
            let name = agent.name;
            if (!name || name.trim() === '') {
              const firstName = agent.first_name || '';
              const lastName = agent.last_name || '';
              name = `${firstName} ${lastName}`.trim();
            }
            if (!name || name.trim() === '') {
              name = agent.email || `Utilisateur ${agent.id}`;
            }

            let roleSuffix = '';
            if (agent.role === 'admin') {
              roleSuffix = ' (Admin)';
            } else if (agent.role === 'superviseur' || agent.role === 'supervisor') {
              roleSuffix = ' (Superviseur)';
            }

            options.push(`<option value="${agent.id}">${name}${roleSuffix}</option>`);
          }
        });

        // Mettre √† jour le select
        select.innerHTML = options.join('\n');

        console.log(`üìù Options HTML g√©n√©r√©es (${options.length} options):`, options);

        // S√©lectionner l'utilisateur courant par d√©faut
        select.value = currentUserId;
        dashboardAgentId = String(currentUserId);
        dashboardSelectedAgent = currentUser;

        console.log(`üë§ Utilisateur s√©lectionn√© par d√©faut: ID=${currentUserId}, Name="${currentUser.name}"`);

        // Mettre √† jour les filtres de projet
        populateProjectFilterOptions(dashboardAgents);
        syncProjectSelectWithAgent(currentUser, { force: true });

        console.log(`‚úÖ Liste des utilisateurs mise √† jour avec ${filteredAgents.length} entr√©es`);
        console.log('üéâ loadAgentsForReport() termin√© avec succ√®s!');

      } catch (error) {
        console.error('‚ùå Erreur dans loadAgentsForReport:', error);

        // Afficher un message d'erreur plus d√©taill√© √† l'utilisateur
        const errorMessage = `Erreur lors du chargement des utilisateurs: ${error.message || 'Erreur inconnue'}`;
        console.error(errorMessage);

        // En cas d'erreur, afficher uniquement l'utilisateur courant
        try {
          const userId = await getUserId();
          select.innerHTML = `<option value="${userId}">Moi (erreur de chargement)</option>`;
          select.value = userId;

          dashboardAgents = [{
            id: Number(userId),
            name: 'Moi',
            role: 'agent',
            project_name: 'Projet non attribu√©'
          }];

          dashboardAgentId = String(userId);
          dashboardSelectedAgent = dashboardAgents[0];

          populateProjectFilterOptions(dashboardAgents);
          syncProjectSelectWithAgent(dashboardSelectedAgent, { force: true });
        } catch (e) {
          console.error('‚ùå Erreur lors de la r√©cup√©ration de l\'utilisateur courant:', e);
          select.innerHTML = '<option value="">Erreur de chargement des utilisateurs</option>';
        }
      }
    }

    function getAgentDisplayNameById(agentId) {
      const agent = findAgentById(agentId);
      if (!agent) return null;
      const fullName = agent.name || `${agent.first_name || ''} ${agent.last_name || ''}`.trim();
      if (fullName) return fullName;
      if (agent.email) return agent.email.split('@')[0];
      return null;
    }

    function getAgentProjectNameById(agentId) {
      const agent = findAgentById(agentId);
      if (!agent) return null;
      return formatProjectDisplay(agent.project_name || agent.project || agent.projectName || '');
    }

    /**
     * Apply the selected filters and update the dashboard
     * @param {Object} options - Additional options
     * @param {boolean} [options.suppressAlerts=false] - Whether to suppress alert messages
     */
    async function applyDashboardFilter(options = {}) {
      try {
        console.log('Application des filtres...', {
          agentId: dashboardAgentId,
          projectFilter: dashboardProjectFilter,
          month: dashboardMonthFilter
        });

        // R√©cup√©rer les valeurs des s√©lecteurs
        const agentSelect = document.getElementById('report-agent-select');
        const monthSelect = document.getElementById('report-month-select');
        const projectSelect = document.getElementById('report-project-select');

        const agentId = agentSelect?.value;
        const monthValue = monthSelect?.value;
        const projectValue = projectSelect?.value?.trim();

        if (!agentId) {
          if (!options.skipValidation) alert('Veuillez s√©lectionner un agent');
          return;
        }
        if (!monthValue) {
          if (!options.skipValidation) alert('Veuillez s√©lectionner un mois');
          return;
        }

        dashboardAgentId = String(agentId);
        dashboardMonthValue = monthValue;
        dashboardMonthFilter = monthValue;
        if (projectValue) {
          dashboardProjectFilter = projectValue;
        }
        dashboardSelectedAgent = findAgentById(agentId) || { id: Number(agentId) };
        const agentProject = getCurrentAgentProject();
        if (agentProject) {
          // Format the project name to match the format used in leaderboard
          const formattedProject = formatProjectDisplay(agentProject);
          // Only set the filter if the formatted project exists in the leaderboard projects
          if (leaderboardProjects.length === 0 || leaderboardProjects.includes(formattedProject)) {
            leaderboardProjectFilter = formattedProject;
            if (leaderboardCache.length > 0) {
              renderLeaderboardTable();
            }
          }
        }

        await loadAgentInfo(dashboardSelectedAgent);
        if (window.agentDashboard?.setAgent) {
          await window.agentDashboard.setAgent({ ...dashboardSelectedAgent, id: Number(agentId) });
        }

        setDashboardLocked(false);

        await Promise.all([
          loadMonthlyReport(monthValue, agentId, { includeAI: false }),
          loadPerformanceStats(agentId),
          loadPresenceStats(agentId),
          initPresenceChart()
        ]);

      } catch (error) {
        console.error('Erreur lors de l\'application des filtres:', error);
        if (!options.suppressAlerts) {
          alert('Erreur lors du chargement des donn√©es. Veuillez r√©essayer.');
        }
      }
    }

    /**
     * Charge le rapport mensuel pour un agent
     * @param {string} monthValue - Mois au format YYYY-MM
     * @param {string|number} [agentId=null] - ID de l'agent
     * @param {Object} [options={}] - Options suppl√©mentaires
     * @param {boolean} [options.includeAI=false] - Inclure l'analyse IA
     */
    async function loadMonthlyReport(monthValue, agentId = null, options = {}) {
      const { includeAI = false } = options;
      const container = document.getElementById('monthly-report-container');
      if (!container) {
        console.warn('Conteneur du rapport mensuel introuvable');
        return;
      }

      const currentRequestId = ++monthlyReportRequestId;

      // Afficher un indicateur de chargement
      container.innerHTML = `
          <div class="text-center py-4">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Chargement...</span>
            </div>
            <p class="mt-2 mb-0">G√©n√©ration du rapport mensuel...</p>
          </div>
        `;

      try {
        // Utiliser l'agent s√©lectionn√© ou l'utilisateur actuel
        let userId = agentId;
        if (!userId) {
          const select = document.getElementById('report-agent-select');
          userId = select?.value;
        }

        if (!userId) {
          userId = await getUserId();
        }

        if (!userId) {
          throw new Error('Aucun agent s√©lectionn√©');
        }

        const monthRange = buildMonthRange(monthValue);
        const resolvedAgentId = Number.isFinite(Number(userId)) ? Number(userId) : userId;
        lastMonthlyReportParams = {
          agentId: resolvedAgentId,
          monthValue
        };

        const params = new URLSearchParams({
          agentId: userId,
          month: monthValue
        });
        params.set('ai', includeAI ? '1' : '0');
        if (dashboardProjectFilter) {
          params.set('project_name', dashboardProjectFilter);
        }

        // L'intercepteur dans app.js ajoutera automatiquement le token
        const response = await fetch(`/api/agents/monthly-report?${params.toString()}`, {
          headers: {
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          // Essayer de r√©cup√©rer le message d'erreur d√©taill√©
          let errorMessage = `Erreur ${response.status}: ${response.statusText}`;
          try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
          } catch (e) {
            // Ignorer si on ne peut pas parser le JSON
          }
          throw new Error(errorMessage);
        }

        const report = await response.json();

        console.group('üìä Donn√©es brutes du rapport re√ßues');
        console.log('M√©tadonn√©es:', report.meta);
        console.log('Donn√©es de pr√©sence:', report.presence);
        console.log('Activit√©s:', {
          total: report.activities?.total,
          breakdown: report.activities?.breakdown,
          performance: report.activities?.performance
        });
        console.log('Objectifs:', report.objectives?.length || 0, 'objectifs');
        console.log('Photos:', report.photos?.length || 0, 'photos');
        console.log('Commentaires:', report.comments || 'Aucun commentaire');
        console.log('Classement projet:', report.projectRanking?.length ? `${report.projectRanking.length} agents` : 'Non disponible');
        console.groupEnd();

        if (currentRequestId !== monthlyReportRequestId) {
          console.debug('Rapport mensuel ignor√© (requ√™te obsol√®te)', { agentId: userId, month: monthValue });
          return;
        }

        if (!report.success) {
          // Si l'erreur est li√©e aux pr√©sences, afficher un message plus clair
          const errorMsg = report.error || report.message || 'Erreur lors de la g√©n√©ration du rapport';
          if (errorMsg.includes('pr√©sences') || errorMsg.includes('checkins')) {
            throw new Error('Aucune donn√©e de pr√©sence trouv√©e pour cet agent ce mois-ci. Le rapport n√©cessite au moins un check-in.');
          }
          throw new Error(errorMsg);
        }

        try {
          const planifFilters = dashboardProjectFilter ? { projectName: dashboardProjectFilter } : {};
          console.log('üîÑ R√©cup√©ration des checkins et planifications locales...');
          console.log('  - agentId:', resolvedAgentId);
          console.log('  - monthRange:', monthRange);
          console.log('  - planifFilters:', planifFilters);

          const [monthlyCheckins, monthlyPlanifications] = await Promise.all([
            fetchMonthlyCheckins(resolvedAgentId, monthRange),
            fetchMonthlyPlanifications(resolvedAgentId, monthRange, planifFilters)
          ]);

          console.log('üì• monthlyCheckins r√©cup√©r√©s:', monthlyCheckins?.length || 0, 'checkins');
          console.log('üì• monthlyPlanifications r√©cup√©r√©es:', monthlyPlanifications?.length || 0, 'planifications');

          if (monthlyCheckins.length) {
            console.group('üßÆ Calcul des statistiques de pr√©sence');
            console.log('Check-ins trouv√©s:', monthlyCheckins.length);
            const computedPresence = summarizePresenceFromCheckins(monthlyCheckins, monthRange);
            console.log('Statistiques calcul√©es:', computedPresence);
            if (computedPresence) {
              report.presence = { 
                ...(report.presence || {}), 
                ...computedPresence 
              };
              console.log('‚úÖ Donn√©es de pr√©sence finales:', report.presence);
            } else {
              console.warn('‚ö†Ô∏è Aucune statistique de pr√©sence calcul√©e');
            }
            console.groupEnd();
            
            // Stocker les check-ins pour l'extraction des lieux parcourus
            report.monthlyCheckins = monthlyCheckins;
          } else {
            console.warn('‚ö†Ô∏è Aucun checkin trouv√© pour cet agent ce mois-ci');
            report.monthlyCheckins = [];
          }

          if (monthlyPlanifications.length) {
            console.group('üßÆ Calcul des statistiques d\'activit√©s');
            console.log('Planifications trouv√©es:', monthlyPlanifications.length);
            const computedActivities = summarizeActivitiesFromPlanifications(monthlyPlanifications);
            console.log('Statistiques calcul√©es:', {
              total: computedActivities?.total,
              breakdown: computedActivities?.breakdown,
              performance: computedActivities?.performance
            });
            if (computedActivities) {
              report.activities = {
                ...(report.activities || {}),
                ...computedActivities
              };
              console.log('‚úÖ Donn√©es d\'activit√©s finales:', report.activities);
            } else {
              console.warn('‚ö†Ô∏è Aucune statistique d\'activit√© calcul√©e');
            }
            console.groupEnd();
          } else {
            console.warn('‚ö†Ô∏è Aucune planification trouv√©e pour cet agent ce mois-ci');
          }

          const agentProjectName =
            dashboardSelectedAgent?.project_name ||
            dashboardSelectedAgent?.project ||
            dashboardSelectedAgent?.projectName ||
            report?.meta?.agent?.project_name ||
            report?.meta?.agent?.project ||
            '';

          const projectForRanking = dashboardProjectFilter || agentProjectName;

          // IMPORTANT :
          // Si le backend a d√©j√† fourni un classement (projectRanking) dans le rapport mensuel,
          // on NE le remplace pas par un recalcul local bas√© uniquement sur les planifications.
          // Cela √©vite de perdre des agents du projet ou des m√©triques de pr√©sence d√©j√† calcul√©es c√¥t√© serveur.
          const hasBackendRanking = Array.isArray(report.projectRanking) && report.projectRanking.length > 0;

          if (hasBackendRanking) {
            console.log('‚ÑπÔ∏è Classement backend d√©j√† pr√©sent dans le rapport, aucun recalcul local du classement projet ne sera effectu√©.', {
              existingCount: report.projectRanking.length,
              project: report.projectRankingProject || projectForRanking || agentProjectName || null
            });
          } else if (projectForRanking) {
            try {
              console.log(`üèÜ Calcul du classement pour le projet: "${projectForRanking}"`);

              // Charger les planifications du projet pour calculer le TEP par agent
              const projectPlanifications = await fetchMonthlyPlanifications(
                null,
                monthRange,
                { projectName: projectForRanking }
              );

              console.log(`üìã Planifications du projet r√©cup√©r√©es: ${projectPlanifications?.length || 0}`);

              // Construire un classement complet (Pr√©sence + TEP + Terrain) pour le mois s√©lectionn√©
              const projectRanking = await computeProjectRankingForMonth(projectForRanking, monthRange, projectPlanifications);

              console.log(`‚úÖ Classement calcul√©: ${projectRanking?.length || 0} agents`);

              if (projectRanking && projectRanking.length > 0) {
                report.projectRanking = projectRanking;
                report.projectRankingProject = projectForRanking;
                console.log('‚úÖ Classement ajout√© au rapport:', {
                  agentsCount: projectRanking.length,
                  project: projectForRanking,
                  firstAgent: projectRanking[0]?.agentName
                });
              } else {
                console.warn('‚ö†Ô∏è Classement vide apr√®s calcul');
              }
            } catch (projectRankingError) {
              console.error('‚ùå Erreur calcul classement projet:', projectRankingError);
            }
          } else {
            console.warn('‚ö†Ô∏è Aucun projet identifi√© pour le classement');
          }

          try {
            const permissionRecord = await fetchPermissionDaysRecord(resolvedAgentId, monthRange.value);
            if (permissionRecord && typeof permissionRecord.days !== 'undefined') {
              report.presence = report.presence || {};
              report.presence.permissionDays = Math.max(0, Number(permissionRecord.days) || 0);
            }
          } catch (permissionError) {
            console.warn('Erreur jours permissionnaires (rapport):', permissionError);
          }
        } catch (dataError) {
          console.warn('Erreur donn√©es mensuelles locales:', dataError);
        } finally {
          renderMonthlyReport(report);
        }
      } catch (error) {
        console.error('Erreur lors du chargement du rapport:', error);

        if (currentRequestId !== monthlyReportRequestId) {
          console.debug('Erreur rapport mensuel ignor√©e (requ√™te obsol√®te)', { agentId, monthValue, error: error.message });
          return;
        }

        // Message d'erreur plus informatif
        let errorMessage = error.message;
        let suggestion = 'Veuillez v√©rifier que vous avez des donn√©es pour ce mois ou r√©essayer plus tard.';

        if (errorMessage.includes('pr√©sences') || errorMessage.includes('checkins')) {
          suggestion = 'Assurez-vous que l\'agent s√©lectionn√© a effectu√© des check-ins pendant ce mois.';
        } else if (errorMessage.includes('500')) {
          suggestion = 'Une erreur serveur s\'est produite. Veuillez contacter l\'administrateur si le probl√®me persiste.';
        }

        container.innerHTML = `
            <div class="alert alert-warning">
              <i class="bi bi-exclamation-triangle me-2"></i>
              <strong>Impossible de charger le rapport mensuel</strong>
              <p class="mb-1 mt-2"><strong>Erreur:</strong> ${errorMessage}</p>
              <small class="text-muted">${suggestion}</small>
            </div>
          `;
      }
    }

    // Fonction pour extraire les lieux parcourus depuis les check-ins
    function extractVisitedLocations(checkins = []) {
      const locationsMap = new Map();
      
      checkins.forEach(checkin => {
        // Extraire les donn√©es g√©ographiques depuis device_info ou directement
        // device_info peut √™tre un objet ou une cha√Æne JSON
        let deviceInfo = {};
        if (checkin.device_info) {
          if (typeof checkin.device_info === 'string') {
            try {
              deviceInfo = JSON.parse(checkin.device_info);
            } catch (e) {
              deviceInfo = {};
            }
          } else if (typeof checkin.device_info === 'object') {
            deviceInfo = checkin.device_info;
          }
        }
        
        const departement = checkin.departement || deviceInfo.departement || null;
        const commune = checkin.commune || deviceInfo.commune || null;
        const arrondissement = checkin.arrondissement || deviceInfo.arrondissement || null;
        const village = checkin.village || deviceInfo.village || null;
        
        // Ignorer si aucune information g√©ographique n'est disponible
        if (!commune && !village && !arrondissement) {
          return;
        }
        
        // Cr√©er une cl√© unique pour chaque lieu
        const locationKey = [
          departement || '',
          commune || '',
          arrondissement || '',
          village || ''
        ].filter(Boolean).join('|');
        
        if (locationKey) {
          if (!locationsMap.has(locationKey)) {
            locationsMap.set(locationKey, {
              departement: departement || 'Non sp√©cifi√©',
              commune: commune || 'Non sp√©cifi√©',
              arrondissement: arrondissement || 'Non sp√©cifi√©',
              village: village || 'Non sp√©cifi√©',
              visits: 0,
              dates: []
            });
          }
          
          const location = locationsMap.get(locationKey);
          location.visits += 1;
          
          // Ajouter la date de visite
          const checkinDate = checkin.created_at || checkin.timestamp || checkin.checkin_time || checkin.start_time;
          if (checkinDate) {
            const date = new Date(checkinDate);
            if (!isNaN(date.getTime())) {
              const dateStr = date.toISOString().split('T')[0];
              if (!location.dates.includes(dateStr)) {
                location.dates.push(dateStr);
              }
            }
          }
        }
      });
      
      // Convertir en tableau et trier par nombre de visites
      return Array.from(locationsMap.values())
        .sort((a, b) => {
          // Trier d'abord par nombre de visites, puis par nombre de jours
          if (b.visits !== a.visits) {
            return b.visits - a.visits;
          }
          return b.dates.length - a.dates.length;
        })
        .map(loc => ({
          ...loc,
          dates: loc.dates.sort()
        }));
    }

    // Fonction pour rendre la section des lieux parcourus
    function renderVisitedLocationsSection(checkins = []) {
      if (!checkins || checkins.length === 0) {
        return '';
      }
      
      const visitedLocations = extractVisitedLocations(checkins);
      
      if (visitedLocations.length === 0) {
        return '';
      }
      
      // Formater les dates
      const formatDate = (dateStr) => {
        const date = new Date(dateStr);
        return date.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' });
      };
      
      const locationsRows = visitedLocations.map((loc, index) => {
        const datesDisplay = loc.dates.length > 0 
          ? loc.dates.slice(0, 5).map(formatDate).join(', ') + (loc.dates.length > 5 ? ` (+${loc.dates.length - 5})` : '')
          : 'N/A';
        
        return `
          <tr>
            <td>${index + 1}</td>
            <td>${escapeHtml(loc.departement)}</td>
            <td>${escapeHtml(loc.commune)}</td>
            <td>${escapeHtml(loc.arrondissement)}</td>
            <td>${escapeHtml(loc.village)}</td>
            <td class="text-center"><span class="badge bg-primary">${loc.visits}</span></td>
            <td class="text-center"><span class="badge bg-info text-dark">${loc.dates.length}</span></td>
            <td class="small text-muted">${datesDisplay}</td>
          </tr>
        `;
      }).join('');
      
      return `
        <section class="report-section page-break-inside-avoid">
          <div class="report-section-header">
            <div>
              <h5><i class="bi bi-geo-alt-fill me-2 text-primary"></i>Lieux Parcourus</h5>
              <small>D√©tail de tous les lieux visit√©s durant le mois</small>
            </div>
            <div class="report-chip-group">
              <span class="report-chip">${visitedLocations.length} lieu${visitedLocations.length > 1 ? 'x' : ''} unique${visitedLocations.length > 1 ? 's' : ''}</span>
              <span class="report-chip">${checkins.length} check-in${checkins.length > 1 ? 's' : ''}</span>
            </div>
          </div>
          
          <div class="table-responsive">
            <table class="table table-hover table-sm">
              <thead class="table-light">
                <tr>
                  <th style="width: 50px;">#</th>
                  <th>D√©partement</th>
                  <th>Commune</th>
                  <th>Arrondissement</th>
                  <th>Village</th>
                  <th class="text-center" style="width: 100px;">Visites</th>
                  <th class="text-center" style="width: 100px;">Jours</th>
                  <th>Dates</th>
                </tr>
              </thead>
              <tbody>
                ${locationsRows}
              </tbody>
            </table>
          </div>
          
          <div class="mt-3">
            <small class="text-muted">
              <i class="bi bi-info-circle me-1"></i>
              Les lieux sont tri√©s par nombre de visites (du plus visit√© au moins visit√©). 
              Les dates affichent les jours o√π l'agent a effectu√© au moins un check-in dans ce lieu.
            </small>
          </div>
        </section>
      `;
    }

    function renderZonesSection(zones) {
      if (!zones || (!zones.communesCount && !zones.villagesCount && !zones.locationsCount)) return '';

      const topCommunesHtml = (zones.topCommunes || []).map(c =>
        `<span class="badge bg-info text-dark me-2 mb-2 p-2"><i class="bi bi-building me-1"></i> ${escapeHtml(c.name)} (${c.count})</span>`
      ).join('');

      const topVillagesHtml = (zones.topVillages || []).map(v =>
        `<span class="badge bg-light text-dark border me-2 mb-2 p-2"><i class="bi bi-geo-alt me-1"></i> ${escapeHtml(v.name)} (${v.count})</span>`
      ).join('');

      return `
          <section class="report-section page-break-inside-avoid">
            <div class="report-section-header">
              <h5><i class="bi bi-map me-2 text-primary"></i>Zones d'Intervention</h5>
            </div>

            <div class="row g-4">
              <div class="col-md-4">
                <div class="card h-100 border-0 shadow-sm bg-light">
                  <div class="card-body text-center">
                    <h6 class="text-muted mb-3">Couverture G√©ographique</h6>
                    <div class="d-flex justify-content-around">
                      <div>
                        <div class="display-6 fw-bold text-primary">${zones.communesCount}</div>
                        <div class="small text-muted">Communes</div>
                      </div>
                      <div>
                        <div class="display-6 fw-bold text-info">${zones.villagesCount}</div>
                        <div class="small text-muted">Villages</div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <div class="col-md-8">
                <div class="card h-100 border-0 shadow-sm">
                  <div class="card-body">
                    <h6 class="text-muted mb-3">Communes les plus visit√©es</h6>
                    <div class="mb-3">
                      ${topCommunesHtml || '<span class="text-muted fst-italic">Aucune donn√©e de commune</span>'}
                    </div>

                    <h6 class="text-muted mb-2">Villages / Localit√©s</h6>
                    <div>
                      ${topVillagesHtml || '<span class="text-muted fst-italic">Aucune donn√©e de village</span>'}
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>
        `;
    }

    function renderMissionsStatsSection(report) {
      if (!report.missionsCount && !report.completedMissionsCount) return '';

      const completionRate = report.missionsCount > 0
        ? Math.round((report.completedMissionsCount / report.missionsCount) * 100)
        : 0;

      return `
          <section class="report-section page-break-inside-avoid">
            <div class="report-section-header">
              <h5><i class="bi bi-briefcase me-2 text-primary"></i>Synth√®se des Missions</h5>
              <span class="badge ${completionRate >= 90 ? 'bg-success' : 'bg-warning'} rounded-pill">
                ${completionRate}% Compl√©tion
              </span>
            </div>

            <div class="row g-4">
              <div class="col-md-3">
                <div class="p-3 border rounded text-center bg-light h-100">
                  <div class="display-6 fw-bold text-primary">${report.missionsCount}</div>
                  <div class="small text-muted text-uppercase fw-bold">Total Missions</div>
                </div>
              </div>
              <div class="col-md-3">
                <div class="p-3 border rounded text-center bg-light h-100">
                  <div class="display-6 fw-bold text-success">${report.completedMissionsCount}</div>
                  <div class="small text-muted text-uppercase fw-bold">Termin√©es</div>
                </div>
              </div>
              <div class="col-md-3">
                <div class="p-3 border rounded text-center bg-light h-100">
                  <div class="display-6 fw-bold text-info">${report.fieldTimeHours}h</div>
                  <div class="small text-muted text-uppercase fw-bold">Temps Terrain</div>
                </div>
              </div>
              <div class="col-md-3">
                <div class="p-3 border rounded text-center bg-light h-100">
                  <div class="display-6 fw-bold text-secondary">${report.avgFieldTimePerDay}h</div>
                  <div class="small text-muted text-uppercase fw-bold">Moyenne / Jour</div>
                </div>
              </div>
            </div>
          </section>
        `;
    }

    /**
     * Nouvelle fonction : Rendu de la section d√©taill√©e des missions quotidiennes
     * Affiche pour chaque jour : date, missions, heures travaill√©es
     */
    function renderDailyMissionsSection(dailyMissions = [], periodLabel = '') {
      if (!Array.isArray(dailyMissions) || dailyMissions.length === 0) return '';

      // Trier par date
      const sortedDays = [...dailyMissions].sort((a, b) =>
        new Date(a.date) - new Date(b.date)
      );

      // Calculer les statistiques globales
      const totalDays = sortedDays.length;
      const totalHours = sortedDays.reduce((sum, day) => sum + (day.totalHours || 0), 0);
      const totalMissions = sortedDays.reduce((sum, day) => sum + (day.missions?.length || 0), 0);
      const avgHoursPerDay = totalDays > 0 ? (totalHours / totalDays).toFixed(1) : 0;

      const formatTime = (hours) => {
        if (!hours || hours <= 0) return '0h00';
        const h = Math.floor(hours);
        const m = Math.round((hours - h) * 60);
        return m > 0 ? `${h}h${String(m).padStart(2, '0')}` : `${h}h`;
      };

      const getHoursBarWidth = (hours, maxHours) => {
        return maxHours > 0 ? Math.min((hours / maxHours) * 100, 100) : 0;
      };

      const maxHoursInDay = Math.max(...sortedDays.map(d => d.totalHours || 0), 8);

      return `
          <section class="report-section">
            <div class="report-section-header">
              <div>
                <h5><i class="bi bi-calendar2-week me-2 text-primary"></i>D√©tail Quotidien des Missions</h5>
                <small>Heures travaill√©es par jour calcul√©es depuis les missions (date_start ‚Üí date_end)</small>
              </div>
              <div class="report-chip-group">
                <span class="report-chip bg-primary text-white">${totalDays} jours</span>
                <span class="report-chip bg-info text-white">${formatTime(totalHours)} total</span>
                <span class="report-chip bg-success text-white">${avgHoursPerDay}h/jour moy.</span>
              </div>
            </div>

            <!-- Statistiques r√©sum√©es -->
            <div class="row g-3 mb-4">
              <div class="col-md-3">
                <div class="card border-0 bg-primary bg-opacity-10 h-100">
                  <div class="card-body text-center py-3">
                    <div class="fs-3 fw-bold text-primary">${totalDays}</div>
                    <div class="small text-muted fw-semibold">Jours travaill√©s</div>
                  </div>
                </div>
              </div>
              <div class="col-md-3">
                <div class="card border-0 bg-success bg-opacity-10 h-100">
                  <div class="card-body text-center py-3">
                    <div class="fs-3 fw-bold text-success">${totalMissions}</div>
                    <div class="small text-muted fw-semibold">Missions r√©alis√©es</div>
                  </div>
                </div>
              </div>
              <div class="col-md-3">
                <div class="card border-0 bg-info bg-opacity-10 h-100">
                  <div class="card-body text-center py-3">
                    <div class="fs-3 fw-bold text-info">${formatTime(totalHours)}</div>
                    <div class="small text-muted fw-semibold">Temps total</div>
                  </div>
                </div>
              </div>
              <div class="col-md-3">
                <div class="card border-0 bg-warning bg-opacity-10 h-100">
                  <div class="card-body text-center py-3">
                    <div class="fs-3 fw-bold text-warning">${avgHoursPerDay}h</div>
                    <div class="small text-muted fw-semibold">Moyenne/jour</div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Timeline d√©taill√©e par jour -->
            <div class="card border-0 shadow-sm">
              <div class="card-body p-4">
                <h6 class="text-muted mb-4">
                  <i class="bi bi-clock-history me-2"></i>Chronologie des journ√©es de travail
                </h6>
                <div class="timeline-container">
                  ${sortedDays.map((day, index) => {
        const dayDate = new Date(day.date);
        const dayName = dayDate.toLocaleDateString('fr-FR', { weekday: 'long' });
        const dayNum = dayDate.toLocaleDateString('fr-FR', { day: '2-digit', month: 'short', year: 'numeric' });
        const missions = day.missions || [];
        const totalHours = day.totalHours || 0;
        const barWidth = getHoursBarWidth(totalHours, maxHoursInDay);

        // Couleur selon les heures
        let barColor = 'bg-success';
        if (totalHours < 4) barColor = 'bg-danger';
        else if (totalHours < 6) barColor = 'bg-warning';
        else if (totalHours < 8) barColor = 'bg-info';

        return `
                      <div class="day-entry mb-4 pb-4 ${index < sortedDays.length - 1 ? 'border-bottom' : ''}">
                        <div class="row align-items-center">
                          <div class="col-md-3">
                            <div class="d-flex align-items-center gap-3">
                              <div class="day-badge bg-primary text-white rounded-circle d-flex align-items-center justify-content-center"
                                   style="width: 50px; height: 50px; font-size: 1.2rem; font-weight: bold;">
                                ${dayDate.getDate()}
                              </div>
                              <div>
                                <div class="fw-bold text-capitalize">${escapeHtml(dayName)}</div>
                                <div class="small text-muted">${escapeHtml(dayNum)}</div>
                              </div>
                            </div>
                          </div>
                          <div class="col-md-9">
                            <div class="mb-2">
                              <div class="d-flex justify-content-between align-items-center mb-1">
                                <span class="small fw-semibold">
                                  <i class="bi bi-clock text-primary me-1"></i>
                                  ${formatTime(totalHours)} de travail
                                </span>
                                <span class="badge ${barColor}">${missions.length} mission(s)</span>
                              </div>
                              <div class="progress" style="height: 12px;">
                                <div class="progress-bar ${barColor}"
                                     role="progressbar"
                                     style="width: ${barWidth}%"
                                     aria-valuenow="${totalHours}"
                                     aria-valuemin="0"
                                     aria-valuemax="${maxHoursInDay}">
                                </div>
                              </div>
                            </div>

                            ${missions.length > 0 ? `
                              <div class="missions-list mt-2">
                                ${missions.map((mission, mIndex) => {
          const startTime = mission.startTime ? new Date(mission.startTime).toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }) : '-';
          const endTime = mission.endTime ? new Date(mission.endTime).toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }) : '-';
          const duration = mission.hours || 0;
          const statusBadge = mission.status === 'completed' ? 'bg-success' : mission.status === 'active' ? 'bg-warning' : 'bg-secondary';
          const statusText = mission.status === 'completed' ? 'Termin√©e' : mission.status === 'active' ? 'En cours' : 'Annul√©e';

          return `
                                    <div class="mission-item p-2 mb-2 bg-light rounded border-start border-3 border-${mission.status === 'completed' ? 'success' : 'warning'}">
                                      <div class="row align-items-center g-2">
                                        <div class="col-md-2 text-center">
                                          <span class="badge ${statusBadge} rounded-pill">${escapeHtml(statusText)}</span>
                                        </div>
                                        <div class="col-md-3">
                                          <div class="small">
                                            <i class="bi bi-clock text-muted me-1"></i>
                                            <strong>${startTime}</strong> ‚Üí <strong>${endTime}</strong>
                                          </div>
                                        </div>
                                        <div class="col-md-2 text-center">
                                          <span class="badge bg-primary">${formatTime(duration)}</span>
                                        </div>
                                        <div class="col-md-5">
                                          <div class="small">
                                            ${mission.commune ? `<i class="bi bi-geo-alt text-info me-1"></i>${escapeHtml(mission.commune)}` : ''}
                                            ${mission.village ? ` ‚Ä¢ ${escapeHtml(mission.village)}` : ''}
                                          </div>
                                          ${mission.note ? `<div class="small text-muted mt-1">${escapeHtml(mission.note)}</div>` : ''}
                                        </div>
                                      </div>
                                    </div>
                                  `;
        }).join('')}
                              </div>
                            ` : `
                              <div class="text-muted small fst-italic">Aucune mission enregistr√©e</div>
                            `}
                          </div>
                        </div>
                      </div>
                    `;
                  }).join('')}
                </div>
              </div>
            </div>
          </section>
        `;
    }

    function renderProjectRankingSection(ranking = [], options = {}) {
      if (!Array.isArray(ranking)) return '';
      
      // Extraire les options avec des valeurs par d√©faut
      const {
        projectName = 'Projet',
        matchProjectName = '',
        agentId = null,
        periodLabel = '',
        totalAgents = ranking.length, // Valeur par d√©faut bas√©e sur le nombre d'entr√©es
        agentRealData = null, // Donn√©es r√©elles de l'agent filtr√© (pr√©sence, temps terrain, etc.)
        dailyMissions = null // Missions quotidiennes pour calculer le temps terrain si n√©cessaire
      } = options;

      const sanitizedProjectName = escapeHtml(projectName || 'Projet');
      // Pour le rapport mensuel, le backend fournit d√©j√† un classement filtr√© par projet.
      // On ne filtre donc QUE si un matchProjectName explicite est fourni (cas du TEP local).
      const normalizedProject = matchProjectName
        ? normalizeProjectIdentifier(matchProjectName)
        : '';

      // Calculer le score composite pour chaque agent
      // Score = 70% pr√©sence + 15% ex√©cution (TEP) + 15% temps terrain
      const calculateCompositeScore = (entry) => {
        const presenceRate = Number(entry.presenceRate || entry.presence_rate || 0);
        const tepRate = Number.isFinite(entry.tep) ? entry.tep : Number(entry.executionRate || entry.tepPercent || 0);
        const fieldTimeHours = Number(entry.fieldTimeHours || entry.field_time_hours || 0);

        // Normaliser le temps terrain (max 8h par jour consid√©r√© comme 100%)
        const maxFieldTimePerDay = 8;
        const workingDays = Number(entry.workingDays || entry.working_days || 22);
        const maxFieldTime = maxFieldTimePerDay * workingDays;
        const fieldTimeRate = maxFieldTime > 0 ? Math.min((fieldTimeHours / maxFieldTime) * 100, 100) : 0;

        const compositeScore = (presenceRate * 0.70) + (tepRate * 0.15) + (fieldTimeRate * 0.15);
        return Math.round(compositeScore * 10) / 10;
      };

      const enrichedRanking = ranking.map(entry => {
        // Recalculer le score composite pour chaque entr√©e
        const calculatedScore = calculateCompositeScore(entry);
        return {
        ...entry,
        projectKey: entry.projectKey || normalizeProjectIdentifier(entry.projectName || entry.project || ''),
        total: entry.total ?? entry.planified ?? 0,
        realized: entry.realized ?? entry.completed ?? 0,
        partially: entry.partially ?? entry.partial ?? 0,
        notRealized: entry.notRealized ?? entry.failed ?? 0,
        tep: Number.isFinite(entry.tep) ? entry.tep : Number(entry.executionRate || entry.tepPercent || 0),
        presenceRate: Number(entry.presenceRate || entry.presence_rate || 0),
        fieldTimeHours: Number(entry.fieldTimeHours || entry.field_time_hours || 0),
          compositeScore: calculatedScore // Toujours utiliser le score recalcul√©
        };
      });

      const filteredRanking = normalizedProject
        ? enrichedRanking.filter(entry => entry.projectKey === normalizedProject)
        : enrichedRanking;

      // Mettre √† jour les valeurs de l'agent s√©lectionn√© avec les donn√©es r√©elles du rapport
      // si elles sont disponibles et meilleures que celles du classement backend
      if (agentId) {
        const agentIdStr = String(agentId);
        const selectedAgentInRanking = filteredRanking.find(e => 
          String(e.agentId || e.agent_id || e.id) === agentIdStr
        );
        
        if (selectedAgentInRanking) {
          // Si on a des donn√©es r√©elles, TOUJOURS les utiliser pour corriger les valeurs du classement
          // M√™me si le classement backend dit 0, les donn√©es r√©elles du rapport sont plus fiables
          if (agentRealData) {
            const currentPresenceRate = Number(selectedAgentInRanking.presenceRate || selectedAgentInRanking.presence_rate || 0);
            const currentFieldTimeHours = Number(selectedAgentInRanking.fieldTimeHours || selectedAgentInRanking.field_time_hours || 0);
            
            // TOUJOURS utiliser les valeurs r√©elles si elles sont meilleures ou si les valeurs actuelles sont √† 0
            // Priorit√© aux donn√©es r√©elles du rapport qui sont calcul√©es diff√©remment
            if (agentRealData.presenceRate > 0 && (currentPresenceRate === 0 || agentRealData.presenceRate >= currentPresenceRate)) {
              selectedAgentInRanking.presenceRate = agentRealData.presenceRate;
              selectedAgentInRanking.presence_rate = agentRealData.presenceRate;
            }
            
            // Pour le temps terrain, TOUJOURS utiliser les donn√©es r√©elles si disponibles
            // Le classement backend peut avoir des valeurs incorrectes (0h) alors que le rapport a les vraies valeurs
            let finalFieldTimeHours = agentRealData?.fieldTimeHours || 0;
            let finalAvgFieldTimePerDay = agentRealData?.avgFieldTimePerDay || 0;
            let finalMissionsCount = agentRealData?.missionsCount || 0;
            
            console.log('üîç Debug temps terrain pour agent filtr√©:', {
              agentId: agentIdStr,
              currentFieldTimeHours,
              agentRealDataFieldTimeHours: agentRealData?.fieldTimeHours,
              dailyMissionsAvailable: !!dailyMissions,
              dailyMissionsLength: dailyMissions?.length || 0,
              dailyMissionsSample: dailyMissions?.slice(0, 3)
            });
            
            // Si les donn√©es r√©elles sont √† 0 mais qu'on a dailyMissions, calculer depuis dailyMissions
            if (finalFieldTimeHours === 0 && dailyMissions && Array.isArray(dailyMissions) && dailyMissions.length > 0) {
              let totalHours = 0;
              dailyMissions.forEach(day => {
                if (day.totalHours && day.totalHours > 0) {
                  totalHours += day.totalHours;
                }
              });
              if (totalHours > 0) {
                finalFieldTimeHours = Math.round(totalHours * 10) / 10;
                const daysWithMissions = dailyMissions.filter(d => d.totalHours > 0).length || 1;
                finalAvgFieldTimePerDay = Math.round((finalFieldTimeHours / daysWithMissions) * 10) / 10;
                finalMissionsCount = dailyMissions.reduce((sum, d) => sum + (d.missions?.length || 0), 0);
                console.log('‚úÖ Temps terrain calcul√© depuis dailyMissions:', {
                  fieldTimeHours: finalFieldTimeHours,
                  avgFieldTimePerDay: finalAvgFieldTimePerDay,
                  missionsCount: finalMissionsCount,
                  totalDays: dailyMissions.length,
                  daysWithMissions
                });
              } else {
                console.warn('‚ö†Ô∏è dailyMissions disponible mais totalHours = 0', {
                  dailyMissions: dailyMissions.map(d => ({ date: d.date, totalHours: d.totalHours, missionsCount: d.missions?.length }))
                });
              }
            } else if (finalFieldTimeHours === 0) {
              console.warn('‚ö†Ô∏è Impossible de calculer le temps terrain:', {
                agentRealDataFieldTimeHours: agentRealData?.fieldTimeHours,
                dailyMissionsAvailable: !!dailyMissions,
                dailyMissionsLength: dailyMissions?.length || 0
              });
            }
            
            // FORCER la mise √† jour avec les valeurs r√©elles du rapport
            // Le probl√®me est que le backend calcule diff√©remment pour l'agent filtr√© dans buildProjectRanking
            // vs dans summarizePresence, donc on doit utiliser les valeurs du rapport qui sont plus fiables
            if (agentRealData) {
              // TOUJOURS utiliser les valeurs du rapport (agentRealData) pour l'agent filtr√©
              // m√™me si elles sont √† 0, car elles sont calcul√©es diff√©remment et plus fiables
              const shouldUpdate = finalFieldTimeHours > 0 || 
                                   (agentRealData.fieldTimeHours > 0 && currentFieldTimeHours === 0) ||
                                   (agentRealData.fieldTimeHours !== currentFieldTimeHours);
              
              if (shouldUpdate) {
                console.log('üîÑ Mise √† jour du temps terrain dans le classement avec les valeurs du rapport:', {
                  ancien: currentFieldTimeHours,
                  nouveau: finalFieldTimeHours || agentRealData.fieldTimeHours,
                  agentRealDataFieldTimeHours: agentRealData.fieldTimeHours,
                  source: finalFieldTimeHours > 0 ? (agentRealData?.fieldTimeHours > 0 ? 'agentRealData' : 'dailyMissions') : 'agentRealData'
                });
                
                // Utiliser finalFieldTimeHours si calcul√© depuis dailyMissions, sinon utiliser agentRealData
                const valueToUse = finalFieldTimeHours > 0 ? finalFieldTimeHours : agentRealData.fieldTimeHours;
                const avgToUse = finalAvgFieldTimePerDay > 0 ? finalAvgFieldTimePerDay : agentRealData.avgFieldTimePerDay;
                const missionsToUse = finalMissionsCount > 0 ? finalMissionsCount : agentRealData.missionsCount;
                
                selectedAgentInRanking.fieldTimeHours = valueToUse;
                selectedAgentInRanking.field_time_hours = valueToUse;
                if (avgToUse > 0 || valueToUse > 0) {
                  selectedAgentInRanking.avgFieldTimePerDay = avgToUse;
                  selectedAgentInRanking.avg_field_time_per_day = avgToUse;
                }
                if (missionsToUse > 0 || valueToUse > 0) {
                  selectedAgentInRanking.missionsCount = missionsToUse;
                  selectedAgentInRanking.missions_count = missionsToUse;
                }
              } else if (agentRealData.fieldTimeHours === 0 && currentFieldTimeHours === 0) {
                // Si les deux sont √† 0, c'est normal - l'agent n'a vraiment pas de temps terrain
                console.log('‚ÑπÔ∏è Temps terrain confirm√© √† 0 pour l\'agent filtr√© (pas de missions/checkins)');
              } else {
                console.warn('‚ö†Ô∏è Valeurs identiques, pas de mise √† jour n√©cessaire:', {
                  finalFieldTimeHours,
                  agentRealDataFieldTimeHours: agentRealData.fieldTimeHours,
                  currentFieldTimeHours
                });
              }
            } else {
              console.error('‚ùå agentRealData non disponible pour l\'agent filtr√©');
            }
            
            // IMPORTANT: Toujours recalculer le score composite avec les nouvelles valeurs
            selectedAgentInRanking.compositeScore = calculateCompositeScore(selectedAgentInRanking);
            
            // Mettre √† jour workingDays si disponible
            if (agentRealData.workingDays) {
              selectedAgentInRanking.workingDays = agentRealData.workingDays;
              selectedAgentInRanking.working_days = agentRealData.workingDays;
            }
          }
        } else {
          // Si l'agent s√©lectionn√© n'est pas dans le classement, essayer de le trouver dans le ranking original
          if (ranking && ranking.length > 0) {
            const originalAgentEntry = ranking.find(e => 
              String(e.agentId || e.agent_id || e.id) === agentIdStr
            );
            if (originalAgentEntry) {
              // Cr√©er une entr√©e avec les valeurs r√©elles si disponibles, sinon utiliser celles du classement
              const entryWithRealData = {
                ...originalAgentEntry,
                agentId: agentId,
                presenceRate: agentRealData?.presenceRate || Number(originalAgentEntry.presenceRate || originalAgentEntry.presence_rate || 0),
                presence_rate: agentRealData?.presenceRate || Number(originalAgentEntry.presenceRate || originalAgentEntry.presence_rate || 0),
                fieldTimeHours: agentRealData?.fieldTimeHours || Number(originalAgentEntry.fieldTimeHours || originalAgentEntry.field_time_hours || 0),
                field_time_hours: agentRealData?.fieldTimeHours || Number(originalAgentEntry.fieldTimeHours || originalAgentEntry.field_time_hours || 0),
                avgFieldTimePerDay: agentRealData?.avgFieldTimePerDay || originalAgentEntry.avgFieldTimePerDay || 0,
                avg_field_time_per_day: agentRealData?.avgFieldTimePerDay || originalAgentEntry.avgFieldTimePerDay || 0,
                missionsCount: agentRealData?.missionsCount || originalAgentEntry.missionsCount || 0,
                missions_count: agentRealData?.missionsCount || originalAgentEntry.missionsCount || 0,
                workingDays: agentRealData?.workingDays || originalAgentEntry.workingDays || 22,
                working_days: agentRealData?.workingDays || originalAgentEntry.workingDays || 22,
                tep: Number.isFinite(originalAgentEntry.tep) ? originalAgentEntry.tep : Number(originalAgentEntry.executionRate || originalAgentEntry.tepPercent || 0)
              };
              entryWithRealData.compositeScore = calculateCompositeScore(entryWithRealData);
              filteredRanking.push(entryWithRealData);
            }
          }
        }
      }

      // Trier par score composite (du plus haut au plus bas) - TRI NORMAL SANS MANIPULATION
      const orderedRanking = filteredRanking
        .sort((a, b) => {
          // D'abord par score composite (d√©croissant)
          const scoreA = Number(a.compositeScore || 0);
          const scoreB = Number(b.compositeScore || 0);
          if (scoreA !== scoreB) {
            return scoreB - scoreA; // Plus haut score en premier
          }
          // Ensuite par TEP si scores √©gaux (d√©croissant)
          const tepA = Number(a.tep || 0);
          const tepB = Number(b.tep || 0);
          if (tepA !== tepB) {
            return tepB - tepA;
          }
          // Enfin par pr√©sence si TEP √©gaux (d√©croissant)
          const presA = Number(a.presenceRate || 0);
          const presB = Number(b.presenceRate || 0);
          return presB - presA;
        })
        .map((entry, index) => ({
          ...entry,
          displayRank: index + 1
        }));

      if (!orderedRanking.length) {
        return `
          <div class="ranking-container">
            <section class="report-section">
              <div class="report-section-header">
                <div>
                  <h5><i class="bi bi-trophy me-2"></i>Classement de l'√âquipe - ${sanitizedProjectName}</h5>
                  ${periodLabel ? `<small>P√©riode ${escapeHtml(periodLabel)}</small>` : ''}
                </div>
                ${totalAgents > 0 ? `
                  <div class="report-chip-group">
                    <span class="report-chip">${totalAgents} agents</span>
                  </div>
                ` : ''}
              </div>
              <p class="text-muted mb-0">Aucun classement disponible pour ce projet sur la p√©riode s√©lectionn√©e.</p>
            </section>
          </div>
        `;
      }

      /**
       * Formate les heures de terrain pour l'affichage
       * @param {number} hours - Nombre d'heures (peut √™tre une valeur d√©cimale)
       * @returns {string} Heures format√©es (ex: "2h30" ou "3h")
       */
      function formatFieldTime(hours) {
        if (hours === null || hours === undefined || isNaN(hours) || hours <= 0) {
          return '0h';
        }
        const h = Math.floor(hours);
        const m = Math.round((hours - h) * 60);
        return m > 0 ? `${h}h${String(m).padStart(2, '0')}` : `${h}h`;
      }

      // Obtenir la classe de badge selon le score
      const getScoreBadgeClass = (score) => {
        if (score >= 80) return 'bg-success';
        if (score >= 60) return 'bg-warning text-dark';
        return 'bg-danger';
      };

      // Trouver le rang de l'agent s√©lectionn√© (v√©rifier plusieurs champs possibles pour l'ID)
      const selectedAgentEntry = agentId ? orderedRanking.find(e => {
        const eId = String(e.agentId || e.agent_id || e.id || '');
        const targetId = String(agentId);
        return eId === targetId;
      }) : null;
      const selectedAgentRank = selectedAgentEntry ? selectedAgentEntry.displayRank : null;
      
      // Log pour d√©boguer
      if (agentId && selectedAgentEntry) {
        console.log('‚úÖ Agent s√©lectionn√© trouv√© dans le classement:', {
          agentId: agentId,
          agentName: selectedAgentEntry.agentName,
          rank: selectedAgentRank,
          compositeScore: selectedAgentEntry.compositeScore,
          presenceRate: selectedAgentEntry.presenceRate,
          tep: selectedAgentEntry.tep,
          fieldTimeHours: selectedAgentEntry.fieldTimeHours
        });
      } else if (agentId) {
        console.warn('‚ö†Ô∏è Agent s√©lectionn√© non trouv√© dans le classement:', {
          agentId: agentId,
          totalAgents: orderedRanking.length,
          agentIds: orderedRanking.map(e => ({
            id: e.agentId || e.agent_id || e.id,
            name: e.agentName
          }))
        });
      }

      const rows = orderedRanking.map(entry => {
        const isSelected = agentId && String(entry.agentId) === String(agentId);
        const tepValue = Number(entry.tep || 0);
        const tepClass = tepValue >= 80 ? 'text-success' : tepValue >= 60 ? 'text-warning' : 'text-danger';
        const presenceValue = Number(entry.presenceRate || 0);
        const presenceClass = presenceValue >= 80 ? 'text-success' : presenceValue >= 60 ? 'text-warning' : 'text-danger';
        const scoreValue = entry.compositeScore || 0;
        const scoreBadgeClass = getScoreBadgeClass(scoreValue);
        const fieldTimeTotal = formatFieldTime(entry.fieldTimeHours);
        const avgFieldTime = formatFieldTime(entry.avgFieldTimePerDay || 0);

        // Obtenir le nom complet (pr√©nom + nom)
        const fullName = entry.agentName || entry.agent_name ||
          [entry.firstName || entry.first_name, entry.lastName || entry.last_name].filter(Boolean).join(' ') ||
          'Agent';

        // M√©daille pour les 3 premiers
        const rankBadge = entry.displayRank === 1 ? 'ü•á' :
          entry.displayRank === 2 ? 'ü•à' :
            entry.displayRank === 3 ? 'ü•â' : `#${entry.displayRank}`;

        return `
            <tr class="${isSelected ? 'table-warning fw-bold' : ''}" ${isSelected ? 'style="background-color: #fff3cd !important; border-left: 4px solid #ffc107;"' : ''}>
              <td class="text-center fw-bold" style="font-size: 1.1rem;">${rankBadge}</td>
              <td>
                <div class="fw-semibold">${escapeHtml(fullName)}${isSelected ? ' <span class="badge bg-primary ms-1">Vous</span>' : ''}</div>
              </td>
              <td class="text-center">
                <span class="fw-semibold ${presenceClass}">${presenceValue.toFixed(1)}%</span>
              </td>
              <td class="text-center">
                <span class="fw-semibold ${tepClass}">${tepValue.toFixed(1)}%</span>
              </td>
              <td class="text-center">
                <div>${fieldTimeTotal}</div>
                <small class="text-muted" style="font-size: 0.7rem;">~${avgFieldTime}/j</small>
              </td>
              <td class="text-center">
                <span class="badge ${scoreBadgeClass}" style="font-size: 0.9rem; padding: 0.4em 0.6em;">${scoreValue.toFixed(1)}</span>
              </td>
            </tr>
          `;
      }).join('');

      // R√©sum√© de l'agent s√©lectionn√©
      const agentSummary = selectedAgentEntry ? `
          <div class="alert alert-info mb-3 py-2">
            <div class="d-flex flex-wrap align-items-center justify-content-between gap-2">
              <div>
                <i class="bi bi-person-badge me-1"></i>
                <strong>${escapeHtml(selectedAgentEntry.agentName || 'Agent')}</strong> est class√©(e)
                <span class="badge bg-primary fs-6">${selectedAgentRank}${selectedAgentRank === 1 ? 'er' : '√®me'}</span>
                sur ${orderedRanking.length} agents
              </div>
              <div class="d-flex flex-wrap gap-2 small">
                <span><i class="bi bi-calendar-check text-primary me-1"></i>Pr√©sence: <strong>${selectedAgentEntry.presenceRate?.toFixed(1) || 0}%</strong></span>
                <span><i class="bi bi-check2-square text-success me-1"></i>TEP: <strong>${selectedAgentEntry.tep?.toFixed(1) || 0}%</strong></span>
                <span><i class="bi bi-geo-alt text-info me-1"></i>Terrain: <strong>${formatFieldTime(selectedAgentEntry.fieldTimeHours)}</strong> (~${formatFieldTime(selectedAgentEntry.avgFieldTimePerDay || 0)}/j)</span>
              </div>
            </div>
          </div>
        ` : '';

      return `
          <section class="report-section">
            <div class="report-section-header">
              <div>
                <h5><i class="bi bi-trophy me-2"></i>Classement de l'√âquipe - ${sanitizedProjectName}</h5>
                ${periodLabel ? `<small>P√©riode ${escapeHtml(periodLabel)}</small>` : ''}
              </div>
              <div class="report-chip-group">
                <span class="report-chip">${orderedRanking.length} agents</span>
                <span class="report-chip bg-light text-dark">Score = 70% Pr√©sence + 15% TEP + 15% Terrain</span>
              </div>
            </div>
            ${agentSummary}
            <div class="table-responsive">
              <table class="table table-hover table-striped mb-0" style="font-size: 0.9rem;">
                <thead class="table-dark">
                  <tr>
                    <th style="width: 60px;" class="text-center">Rang</th>
                    <th>Nom & Pr√©nom</th>
                    <th class="text-center" style="width: 90px;" title="Taux de pr√©sence (70% du score)">Pr√©sence</th>
                    <th class="text-center" style="width: 80px;" title="Taux d'ex√©cution des planifications (15% du score)">TEP</th>
                    <th class="text-center" style="width: 80px;" title="Temps pass√© sur le terrain (15% du score)">Terrain</th>
                    <th class="text-center" style="width: 80px;" title="Score composite global">Score</th>
                  </tr>
                </thead>
                <tbody>
                  ${rows}
                </tbody>
              </table>
            </div>
            <div class="mt-2 d-flex flex-wrap gap-3 small text-muted">
              <span><i class="bi bi-info-circle me-1"></i>TEP = Taux d'Ex√©cution des Planifications</span>
              <span><i class="bi bi-clock me-1"></i>Terrain = Temps entre 1er et dernier check-in/jour</span>
            </div>
          </section>
        `;
    }

    /**
     * Affiche le rapport mensuel avec les donn√©es fournies
     * @param {Object} report - Les donn√©es du rapport √† afficher
     * @returns {void}
     */
    function renderMonthlyReport(report) {
      const container = document.getElementById('monthly-report-container');
      if (!container) return;

      // V√©rifier les donn√©es du rapport
      if (!report) {
        container.innerHTML = `
          <div class="alert alert-warning">
            <i class="bi bi-exclamation-triangle me-2"></i>
            <strong>Aucune donn√©e disponible</strong>
            <p class="mb-0 mt-2">Le rapport demand√© est vide ou n'a pas pu √™tre g√©n√©r√©.</p>
          </div>
        `;
        return;
      }

      const {
        meta = {},
        presence: presenceInput = {},
        activities: activitiesInput = {},
        objectives: objectivesInput = [],
        locations = [],
        photos: photosInput = [],
        comments: commentsInput = {}
      } = report;

      const presenceData = presenceInput || {};
      const activitiesData = activitiesInput || {};
      const breakdownList = Array.isArray(activitiesData.breakdown) ? activitiesData.breakdown : [];
      const activityList = Array.isArray(activitiesData.list) ? activitiesData.list : [];
      const objectiveList = Array.isArray(objectivesInput) ? objectivesInput : [];
      const commentsData = commentsInput || {};
      const rawPhotos = Array.isArray(photosInput) ? photosInput : [];
      const photosList = rawPhotos
        .filter(photo => photo && (photo.url || photo.path || photo.photoUrl || photo.photo_url || photo.file_url || photo.imageUrl))
        .slice(0, 20);
      const fieldPhoto = report.fieldPhoto || null;

      const activityPerformance = activitiesData.performance || null;

      // Formateur de dates ISO (YYYY-MM-DD ou ISO complet) en format fran√ßais JJ/MM/AAAA
      const formatIsoDateToFr = (iso) => {
        if (!iso || typeof iso !== 'string') return 'N/A';
        const raw = iso.slice(0, 10); // YYYY-MM-DD
        const [y, m, d] = raw.split('-');
        if (!y || !m || !d) return 'N/A';
        return `${d.padStart(2, '0')}/${m.padStart(2, '0')}/${y}`;
      };

      const referenceMonthLabel = meta?.month?.label || formatMonthLabel(lastMonthlyReportParams?.monthValue);
      const reportingProject = formatProjectDisplay(
        report.projectRankingProject ||
        meta?.agent?.project_name ||
        getCurrentAgentProject() ||
        ''
      );
      const agentDisplayName = meta?.agent?.name || meta?.agent?.display_name || 'Agent';
      const generationTimestamp = new Date().toLocaleString('fr-FR', { dateStyle: 'long', timeStyle: 'short' });
      const periodStart = meta?.month?.start ? formatIsoDateToFr(meta.month.start) : 'N/A';
      const periodEnd = meta?.month?.end ? formatIsoDateToFr(meta.month.end) : 'N/A';

      // Pour le rapport mensuel, le classement retourn√© par le backend est d√©j√† filtr√© par projet.
      // On n'applique donc PAS de filtre suppl√©mentaire c√¥t√© frontend pour √©viter de masquer des agents.
      const projectMatchValue = '';

      // Calculer le temps terrain de l'agent pour cette p√©riode AVANT l'appel √† renderProjectRankingSection
      // Priorit√©: utiliser les valeurs du classement du projet (plus pr√©cises et coh√©rentes)
      let agentFieldTimeHours = 0;
      let avgFieldTimePerDayValue = 0;
      let missionsCountValue = 0;
      
      // R√©cup√©rer les valeurs depuis plusieurs sources et utiliser la meilleure disponible
      const currentAgentId = meta?.agent?.id || lastMonthlyReportParams?.agentId;
      
      // 1. Chercher dans le classement du projet
      if (report.projectRanking && Array.isArray(report.projectRanking)) {
        const agentRankingEntry = report.projectRanking.find(entry => 
          String(entry.agentId || entry.agent_id || entry.id) === String(currentAgentId)
        );
        if (agentRankingEntry) {
          const rankingFieldTime = Number(agentRankingEntry.fieldTimeHours || agentRankingEntry.field_time_hours || 0);
          const rankingAvgFieldTime = Number(agentRankingEntry.avgFieldTimePerDay || agentRankingEntry.avg_field_time_per_day || 0);
          const rankingMissionsCount = Number(agentRankingEntry.missionsCount || agentRankingEntry.missions_count || agentRankingEntry.completedMissionsCount || agentRankingEntry.completed_missions_count || 0);
          
          // Utiliser les valeurs du classement si elles sont > 0
          if (rankingFieldTime > 0) agentFieldTimeHours = rankingFieldTime;
          if (rankingAvgFieldTime > 0) avgFieldTimePerDayValue = rankingAvgFieldTime;
          if (rankingMissionsCount > 0) missionsCountValue = rankingMissionsCount;
        }
      }
      
      // 2. Fallback: utiliser les valeurs du rapport (report.fieldTimeHours, presenceData, etc.)
      // Toujours v√©rifier ces sources m√™me si le classement a retourn√© 0
      const reportFieldTime = Number(report.fieldTimeHours || presenceData.fieldTimeHours || 0);
      const reportAvgFieldTime = Number(presenceData.avgFieldTimePerDay || 0);
      const reportMissionsCount = Number(presenceData.missionsCount || 0);
      
      console.log('üîç Comparaison des valeurs:', {
        fromRanking: agentFieldTimeHours,
        fromReport: reportFieldTime,
        fromPresenceData: presenceData.fieldTimeHours,
        reportFieldTimeHours: report.fieldTimeHours
      });
      
      // Utiliser la meilleure valeur disponible (max entre classement et rapport)
      // PRIORIT√â AUX VALEURS DU RAPPORT pour l'agent filtr√© car elles sont calcul√©es diff√©remment
      // Le backend calcule diff√©remment dans buildProjectRanking vs summarizePresence
      // Donc on doit TOUJOURS utiliser les valeurs du rapport si elles sont > 0
      if (reportFieldTime > 0) {
        // Si le rapport a une valeur > 0, TOUJOURS l'utiliser pour l'agent filtr√©
        // m√™me si le classement backend dit 0 (car le calcul est diff√©rent)
        console.log('‚úÖ Utilisation de la valeur du rapport pour l\'agent filtr√©:', {
          reportFieldTime,
          rankingFieldTime: agentFieldTimeHours,
          reason: 'Le rapport calcule diff√©remment et est plus fiable pour l\'agent filtr√©'
        });
        agentFieldTimeHours = reportFieldTime;
      } else if (agentFieldTimeHours === 0) {
        // Si les deux sont √† 0, c'est que l'agent n'a vraiment pas de temps terrain
        console.log('‚ÑπÔ∏è Temps terrain √† 0 dans le rapport ET le classement pour l\'agent filtr√©');
      }
      
      if (reportAvgFieldTime > 0) {
        avgFieldTimePerDayValue = reportAvgFieldTime;
      }
      if (reportMissionsCount > 0) {
        missionsCountValue = reportMissionsCount;
      }
      
      // 3. Si toujours √† 0, chercher dans dailyMissions (report.dailyMissions ou presenceData.dailyMissions) pour calculer le temps terrain
      if (agentFieldTimeHours === 0) {
        const dailyMissions = report.dailyMissions || presenceData.dailyMissions || [];
        console.log('üîç Tentative de calcul depuis dailyMissions:', {
          dailyMissionsAvailable: !!dailyMissions,
          dailyMissionsLength: dailyMissions.length,
          dailyMissionsFromReport: !!report.dailyMissions,
          dailyMissionsFromPresence: !!presenceData.dailyMissions,
          sample: dailyMissions.slice(0, 3).map(d => ({ date: d.date, totalHours: d.totalHours, missionsCount: d.missions?.length }))
        });
        
        if (Array.isArray(dailyMissions) && dailyMissions.length > 0) {
          let totalHours = 0;
          dailyMissions.forEach(day => {
            if (day.totalHours && day.totalHours > 0) {
              totalHours += day.totalHours;
            }
          });
          if (totalHours > 0) {
            agentFieldTimeHours = Math.round(totalHours * 10) / 10;
            const daysWithMissions = dailyMissions.filter(d => d.totalHours > 0).length || 1;
            avgFieldTimePerDayValue = Math.round((agentFieldTimeHours / daysWithMissions) * 10) / 10;
            missionsCountValue = dailyMissions.reduce((sum, d) => sum + (d.missions?.length || 0), 0);
            console.log('‚úÖ Temps terrain calcul√© depuis dailyMissions AVANT renderProjectRankingSection:', {
              agentFieldTimeHours,
              avgFieldTimePerDayValue,
              missionsCountValue
            });
          } else {
            console.warn('‚ö†Ô∏è dailyMissions disponible mais totalHours = 0 pour toutes les missions');
          }
        } else {
          console.warn('‚ö†Ô∏è dailyMissions non disponible ou vide');
        }
      }
      
      const presenceRateValue = Number(presenceData.presenceRate || 0);
      const workingDaysValue = Number(presenceData.workingDays || 22);

      // Log pour d√©boguer les valeurs r√©cup√©r√©es
      const agentRankingEntryDebug = report.projectRanking?.find(e => String(e.agentId || e.agent_id || e.id) === String(meta?.agent?.id || lastMonthlyReportParams?.agentId));
      console.log('üîç Valeurs r√©cup√©r√©es pour l\'agent filtr√©:', {
        agentId: meta?.agent?.id || lastMonthlyReportParams?.agentId,
        agentName: meta?.agent?.name,
        fromRanking: {
          fieldTimeHours: agentRankingEntryDebug?.fieldTimeHours,
          presenceRate: agentRankingEntryDebug?.presenceRate,
          avgFieldTimePerDay: agentRankingEntryDebug?.avgFieldTimePerDay,
          missionsCount: agentRankingEntryDebug?.missionsCount
        },
        fromReport: {
          fieldTimeHours: report.fieldTimeHours,
          presenceRate: presenceData.presenceRate,
          avgFieldTimePerDay: presenceData.avgFieldTimePerDay,
          missionsCount: presenceData.missionsCount,
          dailyMissionsCount: (report.dailyMissions || presenceData.dailyMissions || []).length
        },
        finalValues: {
          agentFieldTimeHours,
          presenceRateValue,
          avgFieldTimePerDayValue,
          missionsCountValue
        },
        dailyMissionsAvailable: !!(report.dailyMissions || presenceData.dailyMissions)
      });

      // R√©cup√©rer le nombre total d'agents pour le projet
      const totalAgents = report.projectRanking?.length || 0;

      // Calculer selectedAgentEntry et selectedAgentRank pour le chatbot
      // Trier le classement pour trouver le rang de l'agent
      let selectedAgentEntry = null;
      let selectedAgentRank = null;
      if (report.projectRanking && Array.isArray(report.projectRanking) && currentAgentId) {
        // Trier le classement par score composite (comme dans renderProjectRankingSection)
        const orderedRanking = [...report.projectRanking]
          .sort((a, b) => {
            const scoreA = Number(a.compositeScore || 0);
            const scoreB = Number(b.compositeScore || 0);
            if (scoreA !== scoreB) {
              return scoreB - scoreA;
            }
            const tepA = Number(a.tep || 0);
            const tepB = Number(b.tep || 0);
            if (tepA !== tepB) {
              return tepB - tepA;
            }
            const presA = Number(a.presenceRate || 0);
            const presB = Number(b.presenceRate || 0);
            return presB - presA;
          })
          .map((entry, index) => ({
            ...entry,
            displayRank: index + 1
          }));
        
        // Trouver l'agent s√©lectionn√© dans le classement
        selectedAgentEntry = orderedRanking.find(e => {
          const eId = String(e.agentId || e.agent_id || e.id || '');
          const targetId = String(currentAgentId);
          return eId === targetId;
        });
        selectedAgentRank = selectedAgentEntry ? selectedAgentEntry.displayRank : null;
      }

      // G√©n√©rer la section de classement avec les valeurs r√©elles de l'agent filtr√©
      const rankingSection = renderProjectRankingSection(report.projectRanking, {
        projectName: reportingProject || 'Projet',
        matchProjectName: projectMatchValue,
        agentId: meta?.agent?.id || lastMonthlyReportParams?.agentId,
        periodLabel: referenceMonthLabel || '',
        totalAgents: totalAgents,
        // Passer les valeurs r√©elles de l'agent filtr√© pour corriger le classement
        agentRealData: {
          presenceRate: presenceRateValue,
          fieldTimeHours: agentFieldTimeHours,
          avgFieldTimePerDay: avgFieldTimePerDayValue,
          missionsCount: missionsCountValue,
          workingDays: workingDaysValue
        },
        // Passer aussi dailyMissions pour calculer le temps terrain si n√©cessaire
        dailyMissions: report.dailyMissions || presenceData.dailyMissions || null
      });

      const chipItems = [];
      if (referenceMonthLabel) chipItems.push(`Mois ${referenceMonthLabel}`);
      if (reportingProject) chipItems.push(`Projet ${reportingProject}`);
      chipItems.push(`${presenceData.totalCheckins ?? 0} check-ins`);
      const chipGroup = chipItems.map(text => `<span class="report-chip">${escapeHtml(text)}</span>`).join('');

      const reportCoverSection = `
          <section class="report-section report-cover">
            <div class="report-section-header">
              <div>
                <h5>Rapport mensuel ‚Äî ${escapeHtml(agentDisplayName)}</h5>
                <small>G√©n√©r√© le ${escapeHtml(generationTimestamp)}</small>
              </div>
              <div class="report-chip-group">
                ${chipGroup}
                ${totalAgents > 0 ? `<span class="report-chip">${totalAgents} agents</span>` : ''}
              </div>
            </div>
            <div class="report-cover-details">
              <div class="detail">
                <div class="label">Agent audit√©</div>
                <div class="value">${escapeHtml(agentDisplayName)}</div>
              </div>
              <div class="detail">
                <div class="label">Projet couvert</div>
                <div class="value">${escapeHtml(reportingProject || 'Non sp√©cifi√©')}</div>
              </div>
              <div class="detail">
                <div class="label">Nombre d'agents</div>
                <div class="value"><span id="total-agents-count">${totalAgents}</span> agents</div>
              </div>
              <div class="detail">
                <div class="label">P√©riode calendaire</div>
                <div class="value">${escapeHtml(`${periodStart} ‚Üí ${periodEnd}`)}</div>
              </div>
              <div class="detail">
                <div class="label">Sources utilis√©es</div>
                <div class="value">Planifications &amp; Check-ins CCRB</div>
              </div>
              <div class="detail">
                <div class="label">Port√©e analytique</div>
                <div class="value">${escapeHtml(report.period || 'P√©riode non sp√©cifi√©e')}</div>
              </div>
            </div>
          </section>
        `;

      const formatNumber = (value, decimals = 0) => {
        const num = Number(value);
        if (!Number.isFinite(num)) return '0';
        return num.toFixed(decimals);
      };

      const absenceDays = Math.max((presenceData.workingDays || 0) - (presenceData.workedDays || 0), 0);
      const presenceMetrics = [
        { label: 'Taux de pr√©sence', value: `${formatNumber(presenceData.presenceRate ?? 0, 1)}%` },
        { label: 'Jours de pr√©sence', value: `${presenceData.workedDays ?? 0} / ${presenceData.workingDays ?? 0}` },
        { label: 'Jours permissionnaires', value: `${presenceData.permissionDays ?? 0}` },
        { label: 'Check-ins total', value: `${presenceData.totalCheckins ?? 0}` },
        { label: 'Moyenne / jour', value: `${formatNumber(presenceData.averageCheckinsPerDay ?? 0, 1)}` },
        { label: 'Absences estim√©es', value: `${absenceDays}` }
      ].map(metric => `
          <div class="report-metric-card">
            <div class="metric-value">${escapeHtml(metric.value)}</div>
            <div class="metric-label">${escapeHtml(metric.label)}</div>
          </div>
        `).join('');

      const presenceSection = `
          <section class="report-section">
            <div class="report-section-header">
              <div>
                <h5><i class="bi bi-calendar-check me-2"></i>Tableau de pr√©sence</h5>
                <small>Indicateurs cl√©s du mois</small>
              </div>
            </div>
            <div class="report-metrics-grid">
              ${presenceMetrics}
            </div>
          </section>
        `;

      // Les variables agentFieldTimeHours, avgFieldTimePerDayValue, missionsCountValue, 
      // presenceRateValue et workingDaysValue sont d√©j√† d√©finies plus haut avant l'appel √† renderProjectRankingSection

      // Calculer le score composite de l'agent
      const calculateAgentCompositeScore = () => {
        const presRate = presenceRateValue;
        const tepRate = report.activities?.performance?.executionRate || 0;
        const maxFieldTime = 8 * workingDaysValue;
        const fieldTimeRate = maxFieldTime > 0 ? Math.min((agentFieldTimeHours / maxFieldTime) * 100, 100) : 0;
        return Math.round(((presRate * 0.70) + (tepRate * 0.15) + (fieldTimeRate * 0.15)) * 10) / 10;
      };
      const agentCompositeScore = calculateAgentCompositeScore();
      const agentTepRate = report.activities?.performance?.executionRate || 0;

      // Normaliser le temps terrain pour l'affichage (max 100%)
      const maxFieldTimeForPeriod = 8 * workingDaysValue;
      const fieldTimePercent = maxFieldTimeForPeriod > 0 ? Math.min((agentFieldTimeHours / maxFieldTimeForPeriod) * 100, 100) : 0;

      // Fonction pour obtenir la couleur selon le pourcentage
      const getProgressColor = (value) => {
        if (value >= 80) return '#198754'; // success green
        if (value >= 60) return '#ffc107'; // warning yellow
        return '#dc3545'; // danger red
      };

      // Fonction pour obtenir la classe de couleur
      const getProgressColorClass = (value) => {
        if (value >= 80) return 'bg-success';
        if (value >= 60) return 'bg-warning';
        return 'bg-danger';
      };

      // Formater les heures terrain
      const formatFieldTimeDisplay = (hours) => {
        if (!hours || hours <= 0) return '0h';
        const h = Math.floor(hours);
        const m = Math.round((hours - h) * 60);
        return m > 0 ? `${h}h${String(m).padStart(2, '0')}` : `${h}h`;
      };

      // Calculer les totaux d'activit√©s AVANT la cr√©ation de visualizationSection
      // pour garantir la coh√©rence entre le tableau r√©capitulatif et le d√©tail.
      const countByStatus = (predicate) =>
        activityList.filter(act => predicate(detectActivityStatus(act.result))).length;

      // Total planifi√© = nombre total d'interventions dans la p√©riode
      // On se base sur la liste r√©elle des activit√©s, plus fiable que activitiesData.total.
      const plannedTotal = activityList.length;

      // R√©partition du total par statut
      const realizedTotal = countByStatus(status => status === 'realized');
      const partiallyTotal = countByStatus(status => status === 'partiallyRealized');
      const inProgressTotal = countByStatus(status => status === 'inProgress');
      const notRealizedRaw = countByStatus(status => status === 'notRealized');
      const plannedOnlyRaw = countByStatus(status => status === 'planned');
      const withoutStatusTotal = countByStatus(status => status === 'unknown');

      // Pour le tableau r√©capitulatif, on consid√®re que les activit√©s "PLANIFIE"
      // mais non encore r√©alis√©es font partie des "Non r√©alis√©es".
      const notRealizedTotal = notRealizedRaw + plannedOnlyRaw;

      // TEP = r√©alis√© / total planifi√©
      const executionRate = plannedTotal > 0
        ? Math.round((realizedTotal / plannedTotal) * 1000) / 10
        : 0;

      // Calculer les KPI compl√©mentaires pour le graphique
      const checkinsData = report.presence?.totalCheckins || 0;
      const workedDays = report.presence?.workedDays || 0;
      const plannedDays = report.presence?.plannedDays || report.activities?.plannedDays || 0;
      const avgCheckinsPerDay = workedDays > 0 ? Math.round((checkinsData / workedDays) * 10) / 10 : 0;
      const punctualityRate = plannedDays > 0 ? Math.round((workedDays / plannedDays) * 1000) / 10 : 0;
      const regularityScore = workedDays >= 5 ? Math.min(100, Math.round((workedDays / plannedDays) * 100)) : 0;
      const uniqueActivityTypes = new Set(activityList.map(a => (a.description || '').toLowerCase().substring(0, 30))).size;
      const diversityScore = plannedTotal > 0 ? Math.round((uniqueActivityTypes / Math.min(plannedTotal, 10)) * 100) : 0;
      const efficiencyHours = realizedTotal > 0 ? Math.round((agentFieldTimeHours / realizedTotal) * 10) / 10 : 0;
      // Normaliser l'efficacit√© pour le graphique (max 4h par activit√© = 100%)
      const efficiencyScore = Math.min(100, (efficiencyHours / 4) * 100);
      // Normaliser le temps terrain pour le graphique (max 8h/jour * workingDays = 100%)
      // Utiliser les m√™mes valeurs que pour le calcul du score composite
      const maxFieldTimeForChart = 8 * workingDaysValue;
      const fieldTimeScore = maxFieldTimeForChart > 0 ? Math.min(100, (agentFieldTimeHours / maxFieldTimeForChart) * 100) : 0;

      // Section des visualisations statistiques - Graphique tout-en-un
      const visualizationSection = `
          <section class="report-section">
            <div class="report-section-header">
              <div>
                <h5><i class="bi bi-graph-up me-2"></i>Visualisation des Performances</h5>
                <small>Aper√ßu graphique unifi√© des indicateurs cl√©s de l'agent</small>
              </div>
            </div>

            <div class="row g-4">
              <!-- Indicateurs d√©taill√©s avec valeurs -->
              <div class="col-12">
                <div class="card border-0 shadow-sm">
                  <div class="card-body p-4">
                    <h6 class="text-muted mb-4 fw-semibold">D√©tail des Indicateurs</h6>
                    <div class="table-responsive">
                      <table class="table table-hover align-middle mb-0">
                        <thead class="table-light">
                          <tr>
                            <th style="width: 30%;">Indicateur</th>
                            <th style="width: 20%;" class="text-center">Valeur</th>
                            <th style="width: 30%;">D√©tail</th>
                            <th style="width: 20%;">Progression</th>
                          </tr>
                        </thead>
                        <tbody>
                          <!-- Score Composite -->
                          <tr>
                            <td>
                              <div class="d-flex align-items-center">
                                <i class="bi bi-star-fill text-primary me-2 fs-5"></i>
                                <span class="fw-semibold">Score Composite</span>
                      </div>
                            </td>
                            <td class="text-center">
                              <span class="badge ${getProgressColorClass(agentCompositeScore)} fs-6 px-3 py-2">${agentCompositeScore.toFixed(1)}</span>
                            </td>
                            <td>
                              <small class="text-muted">Score global de performance</small>
                            </td>
                            <td>
                              <div class="progress" style="height: 20px;">
                                <div class="progress-bar ${getProgressColorClass(agentCompositeScore)} d-flex align-items-center justify-content-center fw-semibold"
                                  role="progressbar" style="width: ${Math.min(agentCompositeScore, 100)}%">
                                  ${Math.min(agentCompositeScore, 100).toFixed(0)}%
                    </div>
                  </div>
                            </td>
                          </tr>

                          <!-- Pr√©sence -->
                          <tr>
                            <td>
                              <div class="d-flex align-items-center">
                                <i class="bi bi-calendar-check text-primary me-2 fs-5"></i>
                                <span class="fw-semibold">Pr√©sence</span>
                </div>
                            </td>
                            <td class="text-center">
                              <span class="badge ${getProgressColorClass(presenceRateValue)} fs-6 px-3 py-2">${presenceRateValue.toFixed(1)}%</span>
                            </td>
                            <td>
                              <small class="text-muted">${presenceData.workedDays || 0}/${workingDaysValue} jours</small>
                            </td>
                            <td>
                              <div class="progress" style="height: 20px;">
                                <div class="progress-bar ${getProgressColorClass(presenceRateValue)} d-flex align-items-center justify-content-center fw-semibold"
                                  role="progressbar" style="width: ${Math.min(presenceRateValue, 100)}%">
                                  ${Math.min(presenceRateValue, 100).toFixed(0)}%
              </div>
                              </div>
                            </td>
                          </tr>

                          <!-- TEP -->
                          <tr>
                            <td>
                              <div class="d-flex align-items-center">
                                <i class="bi bi-check2-square text-success me-2 fs-5"></i>
                                <span class="fw-semibold">Ex√©cution (TEP)</span>
                      </div>
                            </td>
                            <td class="text-center">
                              <span class="badge ${getProgressColorClass(agentTepRate)} fs-6 px-3 py-2">${agentTepRate.toFixed(1)}%</span>
                            </td>
                            <td>
                              <small class="text-muted">${realizedTotal}/${plannedTotal} activit√©s</small>
                            </td>
                            <td>
                              <div class="progress" style="height: 20px;">
                                <div class="progress-bar ${getProgressColorClass(agentTepRate)} d-flex align-items-center justify-content-center fw-semibold"
                                  role="progressbar" style="width: ${Math.min(agentTepRate, 100)}%">
                                  ${Math.min(agentTepRate, 100).toFixed(0)}%
                      </div>
                    </div>
                            </td>
                          </tr>

                          <!-- Temps Terrain -->
                          <tr>
                            <td>
                              <div class="d-flex align-items-center">
                                <i class="bi bi-geo-alt text-info me-2 fs-5"></i>
                                <span class="fw-semibold">Temps Terrain</span>
                      </div>
                            </td>
                            <td class="text-center">
                              <span class="badge ${getProgressColorClass(fieldTimeScore)} fs-6 px-3 py-2">${formatFieldTimeDisplay(agentFieldTimeHours)}</span>
                            </td>
                            <td>
                              <small class="text-muted">${formatFieldTimeDisplay(avgFieldTimePerDayValue)}/jour ‚Ä¢ ${missionsCountValue} mission(s)</small>
                            </td>
                            <td>
                              <div class="progress" style="height: 20px;">
                                <div class="progress-bar ${getProgressColorClass(fieldTimeScore)} d-flex align-items-center justify-content-center fw-semibold"
                                  role="progressbar" style="width: ${Math.min(fieldTimeScore, 100)}%">
                                  ${Math.min(fieldTimeScore, 100).toFixed(0)}%
                      </div>
                    </div>
                            </td>
                          </tr>

                          <!-- Ponctualit√© -->
                          <tr>
                            <td>
                              <div class="d-flex align-items-center">
                                <i class="bi bi-clock-history text-primary me-2 fs-5"></i>
                                <span class="fw-semibold">Ponctualit√©</span>
                      </div>
                            </td>
                            <td class="text-center">
                              <span class="badge bg-primary bg-opacity-10 text-primary fs-6 px-3 py-2">${punctualityRate.toFixed(1)}%</span>
                            </td>
                            <td>
                              <small class="text-muted">${workedDays}/${plannedDays} jours</small>
                            </td>
                            <td>
                              <div class="progress" style="height: 20px;">
                                <div class="progress-bar bg-primary d-flex align-items-center justify-content-center fw-semibold"
                                  role="progressbar" style="width: ${Math.min(punctualityRate, 100)}%">
                                  ${Math.min(punctualityRate, 100).toFixed(0)}%
                      </div>
                    </div>
                            </td>
                          </tr>

                          <!-- R√©gularit√© -->
                          <tr>
                            <td>
                              <div class="d-flex align-items-center">
                                <i class="bi bi-calendar-check text-warning me-2 fs-5"></i>
                                <span class="fw-semibold">R√©gularit√©</span>
                  </div>
                            </td>
                            <td class="text-center">
                              <span class="badge bg-warning bg-opacity-10 text-warning fs-6 px-3 py-2">${regularityScore}%</span>
                            </td>
                            <td>
                              <small class="text-muted">${avgCheckinsPerDay.toFixed(1)} check-ins/jour</small>
                            </td>
                            <td>
                              <div class="progress" style="height: 20px;">
                                <div class="progress-bar bg-warning d-flex align-items-center justify-content-center fw-semibold"
                                  role="progressbar" style="width: ${Math.min(regularityScore, 100)}%">
                                  ${Math.min(regularityScore, 100)}%
                </div>
              </div>
                            </td>
                          </tr>

                          <!-- Diversit√© -->
                          <tr>
                            <td>
                              <div class="d-flex align-items-center">
                                <i class="bi bi-diagram-3 text-info me-2 fs-5"></i>
                                <span class="fw-semibold">Diversit√©</span>
            </div>
                            </td>
                            <td class="text-center">
                              <span class="badge bg-info bg-opacity-10 text-info fs-6 px-3 py-2">${uniqueActivityTypes}</span>
                            </td>
                            <td>
                              <small class="text-muted">${diversityScore}% types diff√©rents</small>
                            </td>
                            <td>
                              <div class="progress" style="height: 20px;">
                                <div class="progress-bar bg-info d-flex align-items-center justify-content-center fw-semibold"
                                  role="progressbar" style="width: ${Math.min(diversityScore, 100)}%">
                                  ${Math.min(diversityScore, 100)}%
                                </div>
                              </div>
                            </td>
                          </tr>

                          <!-- Efficacit√© -->
                          <tr>
                            <td>
                              <div class="d-flex align-items-center">
                                <i class="bi bi-lightning-charge text-success me-2 fs-5"></i>
                                <span class="fw-semibold">Efficacit√©</span>
                        </div>
                            </td>
                            <td class="text-center">
                              <span class="badge bg-success bg-opacity-10 text-success fs-6 px-3 py-2">${efficiencyHours.toFixed(1)}h</span>
                            </td>
                            <td>
                              <small class="text-muted">h/activit√© r√©alis√©e</small>
                            </td>
                            <td>
                              <div class="progress" style="height: 20px;">
                                <div class="progress-bar bg-success d-flex align-items-center justify-content-center fw-semibold"
                                  role="progressbar" style="width: ${Math.min(efficiencyScore, 100)}%">
                                  ${Math.min(efficiencyScore, 100).toFixed(0)}%
                      </div>
                        </div>
                            </td>
                          </tr>
                        </tbody>
                      </table>
                      </div>
                        </div>
                      </div>
                        </div>

              <!-- Graphique Radar Principal - Sous les indicateurs -->
              <div class="col-12 mt-4">
                <div class="card border-0 shadow-sm">
                  <div class="card-body p-4">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                      <h6 class="text-muted mb-0 fw-semibold">
                        <i class="bi bi-radar me-2"></i>Profil de Performance Complet
                      </h6>
                      <div class="text-end">
                        <div class="fs-4 fw-bold" style="color: ${getProgressColor(agentCompositeScore)}">
                          ${agentCompositeScore.toFixed(1)}<small class="fs-6 text-muted">/100</small>
                      </div>
                        <small class="text-muted">Score Composite</small>
                        </div>
                      </div>
                    <div style="position: relative; height: 500px;">
                      <canvas id="performanceRadarChart"></canvas>
                    </div>
                    <div class="mt-3 text-center">
                      <small class="text-muted">
                        <i class="bi bi-info-circle me-1"></i>
                        Score = 70% Pr√©sence + 15% TEP + 15% Terrain
                      </small>
                  </div>
                </div>
              </div>
            </div>
            </div>

          </section>
        `;

      const getBreakdownCount = (statusKey) => {
        const entry = breakdownList.find(item => item.key === statusKey);
        return entry ? entry.count : 0;
      };

      const formatActivityResult = (value) => {
        if (!value) return 'Non √©valu√©';
        return String(value).replace(/_/g, ' ').toUpperCase();
      };

      const getResultBadgeClass = (value) => {
        const normalized = String(value || '').toLowerCase();
        if (normalized.includes('realise') && !normalized.includes('partiellement')) return 'bg-success';
        if (normalized.includes('partiel')) return 'bg-warning text-dark';
        if (normalized.includes('cours')) return 'bg-info text-dark';
        if (normalized.includes('non')) return 'bg-danger';
        return 'bg-secondary';
      };

      const formatActivityDate = (value) => {
        if (!value) return '-';
        const parsed = new Date(value);
        return Number.isNaN(parsed.getTime()) ? String(value) : parsed.toLocaleDateString('fr-FR');
      };

      const realizedHighlights = activityList
        .filter(act => detectActivityStatus(act.result) === 'realized')
        .slice(0, 3);

      const pendingHighlights = activityList
        .filter(act => {
          const status = detectActivityStatus(act.result);
          return status === 'planned' || status === 'notRealized';
        })
        .slice(0, 3);

      const highlightList = (items) => items.length ? `
              <ul class="mb-0">
                ${items.map(act => `
                  <li>
                    <strong>${formatActivityDate(act.date)}</strong> ‚Äî ${escapeHtml(act.description || 'Sans description')}
                    (${escapeHtml(formatActivityResult(act.result))})
                  </li>
                `).join('')}
              </ul>
            ` : '';

      // Les totaux ont d√©j√† √©t√© calcul√©s plus haut, on r√©utilise les variables existantes
      const tepBadgeClass = executionRate >= 80 ? 'bg-success' : executionRate >= 60 ? 'bg-warning text-dark' : 'bg-danger';

      const activitySummaryTable = `
          <div class="table-responsive mb-4">
            <table class="table table-bordered align-middle text-center">
              <thead class="table-light">
                <tr>
                  <th>Planifi√©</th>
                  <th>R√©alis√©</th>
                  <th>Partiel</th>
                  <th>En cours</th>
                  <th>Non r√©alis√©</th>
                  <th>Sans statut</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>${plannedTotal}</strong></td>
                  <td class="text-success fw-semibold">${realizedTotal}</td>
                  <td class="text-warning fw-semibold">${partiallyTotal}</td>
                  <td class="text-info fw-semibold">${inProgressTotal}</td>
                  <td class="text-danger fw-semibold">${notRealizedTotal}</td>
                  <td class="text-muted fw-semibold">${withoutStatusTotal}</td>
                </tr>
              </tbody>
            </table>
          </div>
        `;

      // Section "R√©partition des Activit√©s" avec les valeurs calcul√©es
      const activityDistributionSection = `
          <div class="row mt-3 mb-4">
            <div class="col-12">
              <div class="card border-0 shadow-sm">
                <div class="card-body p-3">
                  <h6 class="text-muted mb-2">
                    <i class="bi bi-pie-chart me-2"></i>R√©partition des Activit√©s
                  </h6>
                  <div class="row g-2 text-center">
                    <div class="col-6 col-sm-4 col-md">
                      <div class="p-2 rounded h-100" style="background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);">
                        <div class="fs-4 fw-bold text-success">${realizedTotal}</div>
                        <small class="text-success" style="font-size: 0.7rem;">R√©alis√©es</small>
                      </div>
                    </div>
                    <div class="col-6 col-sm-4 col-md">
                      <div class="p-2 rounded h-100" style="background: linear-gradient(135deg, #fff3cd 0%, #ffeeba 100%);">
                        <div class="fs-4 fw-bold text-warning">${partiallyTotal}</div>
                        <small class="text-warning" style="font-size: 0.7rem;">Partielles</small>
                      </div>
                    </div>
                    <div class="col-6 col-sm-4 col-md">
                      <div class="p-2 rounded h-100" style="background: linear-gradient(135deg, #cce5ff 0%, #b8daff 100%);">
                        <div class="fs-4 fw-bold text-info">${inProgressTotal}</div>
                        <small class="text-info" style="font-size: 0.7rem;">En cours</small>
                      </div>
                    </div>
                    <div class="col-6 col-sm-6 col-md">
                      <div class="p-2 rounded h-100" style="background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);">
                        <div class="fs-4 fw-bold text-danger">${notRealizedTotal}</div>
                        <small class="text-danger" style="font-size: 0.7rem;">Non r√©alis√©es</small>
                      </div>
                    </div>
                    <div class="col-12 col-sm-6 col-md">
                      <div class="p-2 rounded h-100" style="background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);">
                        <div class="fs-4 fw-bold text-secondary">${withoutStatusTotal}</div>
                        <small class="text-secondary" style="font-size: 0.7rem;">Sans statut</small>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;

      const activityKpiTable = `
          <div class="table-responsive mb-4">
            <table class="table table-striped align-middle">
              <thead class="table-light">
                <tr>
                  <th style="width: 35%;">Indicateur</th>
                  <th style="width: 20%;">Valeur</th>
                  <th>Observation</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>TEP (r√©alis√© / planifi√©)</td>
                  <td>
                    <span class="badge ${tepBadgeClass}">${executionRate.toFixed(1)}%</span>
                  </td>
                  <td>${realizedTotal}/${plannedTotal} activit√©s totalement r√©alis√©es</td>
                </tr>
                <tr>
                  <td>Activit√©s partiellement r√©alis√©es</td>
                  <td>${partiallyTotal}</td>
                  <td>Actions compl√©mentaires √† planifier</td>
                </tr>
                <tr>
                  <td>Activit√©s en cours</td>
                  <td>${inProgressTotal}</td>
                  <td>Suivi en cours de p√©riode</td>
                </tr>
                <tr>
                  <td>Activit√©s non r√©alis√©es</td>
                  <td>${notRealizedTotal}</td>
                  <td>Analyse des causes √† pr√©voir</td>
                </tr>
                <tr>
                  <td>Activit√©s sans statut</td>
                  <td>${withoutStatusTotal}</td>
                  <td>Saisie des r√©sultats attendue</td>
                </tr>
              </tbody>
            </table>
          </div>
        `;

      const shouldRenderActivities =
        (plannedTotal ?? 0) > 0 ||
        (realizedTotal ?? 0) > 0 ||
        (partiallyTotal ?? 0) > 0 ||
        (inProgressTotal ?? 0) > 0 ||
        (notRealizedTotal ?? 0) > 0 ||
        breakdownList.length > 0 ||
        activityList.length > 0;

      const activityNarrative = !shouldRenderActivities ? '' : `
              <div class="activity-narrative mb-4">
                <p>
                  ${realizedTotal > 0
          ? `Au cours du mois, <strong>${realizedTotal}</strong> activit√©${realizedTotal > 1 ? 's ont √©t√© men√©es' : ' a √©t√© men√©e'} √† terme, en compl√©ment des ${partiallyTotal} actions partiellement cl√¥tur√©es.`
          : 'Aucune activit√© n‚Äôa √©t√© d√©clar√©e comme totalement r√©alis√©e ce mois-ci.'}
                </p>
                ${(plannedTotal > 0 || notRealizedTotal > 0 || inProgressTotal > 0) ? `
                  <p>
                    ${plannedTotal > 0 ? `Sur <strong>${plannedTotal}</strong> interventions planifi√©es,` : 'Concernant les interventions planifi√©es,'}
                    ${notRealizedTotal > 0 ? `<strong>${notRealizedTotal}</strong> sont rest√©es non r√©alis√©es` : 'la plupart ont √©t√© ex√©cut√©es'}
                    ${inProgressTotal > 0 ? `et ${inProgressTotal} sont encore en cours de finalisation` : ''}.
                    ${notRealizedTotal > 0 ? 'Un suivi sp√©cifique est recommand√© afin de documenter les obstacles rencontr√©s.' : ''}
                  </p>
                ` : ''}
                ${realizedHighlights.length ? `
                  <div class="mb-3">
                    <h6 class="text-success mb-2"><i class="bi bi-check2-circle me-2"></i>Activit√©s men√©es</h6>
                    ${highlightList(realizedHighlights)}
                  </div>
                ` : ''}
                ${pendingHighlights.length ? `
                  <div class="mb-0">
                    <h6 class="text-danger mb-2"><i class="bi bi-exclamation-triangle me-2"></i>Activit√©s planifi√©es/non r√©alis√©es</h6>
                    ${highlightList(pendingHighlights)}
                  </div>
                ` : ''}
              </div>
            `;

      // Section d√©taill√©e des activit√©s non r√©alis√©es
      const unrealizedActivities = activityList.filter(act => {
        const status = detectActivityStatus(act.result);
        return status === 'notRealized' || status === 'planned';
      });

      const unrealizedSection = unrealizedActivities.length > 0 ? `
              <div class="mt-4 p-3 bg-light rounded border-start border-danger border-4">
                <h6 class="text-danger mb-3">
                  <i class="bi bi-exclamation-circle me-2"></i>
                  D√©tail des activit√©s non r√©alis√©es (${unrealizedActivities.length})
                </h6>
                <div class="table-responsive">
                  <table class="table table-sm table-hover mb-0">
                    <thead class="table-light">
                      <tr>
                        <th style="width: 100px;">Date</th>
                        <th>Description de l'activit√©</th>
                        <th style="width: 150px;">Statut</th>
                        <th style="width: 150px;">Projet</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${unrealizedActivities.map(act => `
                        <tr>
                          <td class="text-nowrap">${act.date ? new Date(act.date).toLocaleDateString('fr-FR') : '-'}</td>
                          <td>${escapeHtml(act.description || 'Sans description')}</td>
                          <td>
                            <span class="badge bg-danger">${escapeHtml(formatActivityResult(act.result) || 'Non r√©alis√©')}</span>
                          </td>
                          <td>${escapeHtml(act.project || reportingProject || '-')}</td>
                        </tr>
                      `).join('')}
                    </tbody>
                  </table>
                </div>
                <p class="text-muted small mb-0 mt-2">
                  <i class="bi bi-info-circle me-1"></i>
                  Ces activit√©s planifi√©es n'ont pas √©t√© r√©alis√©es ou sont rest√©es sans suivi. Une analyse des causes est recommand√©e.
                </p>
              </div>
            ` : '';

      const activitySection = !shouldRenderActivities ? '' : `
          <section class="report-section">
            <div class="report-section-header">
              <div>
                <h5><i class="bi bi-list-task me-2"></i>Activit√©s (${activitiesData.total ?? 0})</h5>
                <small>Analyse d√©taill√©e des interventions</small>
              </div>
            </div>
                ${activityNarrative}
            ${activitySummaryTable}
            ${activityDistributionSection}
            ${activityKpiTable}
            ${fieldPhoto ? `
              <div class="mt-4">
                <h6 class="mb-2"><i class="bi bi-camera me-2"></i>Photo de terrain (exemple)</h6>
                <div class="d-flex align-items-start gap-3">
                  <img src="${fieldPhoto.url}" alt="Photo de terrain" class="img-thumbnail" style="max-width: 260px; max-height: 260px; object-fit: cover;">
                  <div class="small text-muted">
                    ${fieldPhoto.date ? `<div><strong>Date :</strong> ${new Date(fieldPhoto.date).toLocaleString('fr-FR')}</div>` : ''}
                    ${fieldPhoto.location ? `<div><strong>Lieu :</strong> ${escapeHtml(fieldPhoto.location)}</div>` : ''}
                    <div class="mt-2">Photo extraite des validations de pr√©sence (presence_validations).</div>
                  </div>
                </div>
              </div>
            ` : ''}
            ${breakdownList.length ? `
              <div class="table-responsive mb-4">
                <table class="table table-sm table-hover align-middle">
                  <thead class="table-light">
                    <tr>
                      <th>Statut d√©taill√©</th>
                      <th style="width: 120px;" class="text-center">Volume</th>
                      <th style="width: 120px;" class="text-center">Part (%)</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${breakdownList.map(item => `
                      <tr>
                        <td>${escapeHtml(item.label)}</td>
                        <td class="text-center fw-semibold">${item.count}</td>
                        <td class="text-center">${item.percentage}%</td>
                      </tr>
                    `).join('')}
                  </tbody>
                </table>
              </div>
            ` : ''}
            ${activityList.length ? `
              <div class="table-responsive">
                <table class="table table-striped table-hover align-middle">
                  <thead class="table-light">
                    <tr>
                      <th style="width: 140px;">Date</th>
                      <th>Description</th>
                      <th style="width: 180px;">R√©sultat</th>
                      <th style="width: 200px;">Projet</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${activityList.map(act => {
        const resultLabel = formatActivityResult(act.result);
        return `
                        <tr>
                          <td>${act.date ? new Date(act.date).toLocaleDateString('fr-FR') : '-'}</td>
                          <td>${escapeHtml(act.description || 'Sans description')}</td>
                          <td>
                            <span class="badge ${getResultBadgeClass(act.result)}">${escapeHtml(resultLabel)}</span>
                          </td>
                          <td>${escapeHtml(act.project || reportingProject || '-')}</td>
                        </tr>
                      `;
      }).join('')}
                  </tbody>
                </table>
              </div>
            ` : '<p class="text-muted mb-0">Aucune activit√© enregistr√©e</p>'}
            ${unrealizedSection}
          </section>
        `;

      const objectivesSection = objectiveList.length ? `
          <section class="report-section">
            <div class="report-section-header">
              <div>
                <h5><i class="bi bi-bullseye me-2"></i>Objectifs</h5>
                <small>Suivi des engagements individuels</small>
              </div>
            </div>
            ${objectiveList.map(obj => `
              <div class="mb-3">
                <div class="d-flex justify-content-between mb-2">
                  <strong>${escapeHtml(obj.title)}</strong>
                  <span class="badge ${obj.progressPercent >= 100 ? 'bg-success' : obj.progressPercent >= 50 ? 'bg-warning' : 'bg-danger'}">
                    ${obj.progressPercent}%
                  </span>
                </div>
                <div class="progress" style="height: 20px;">
                  <div class="progress-bar ${obj.progressPercent >= 100 ? 'bg-success' : obj.progressPercent >= 50 ? 'bg-warning' : 'bg-danger'}" 
                       style="width: ${obj.progressPercent}%">
                    ${escapeHtml(`${obj.currentValue} / ${obj.targetValue}`)}
                  </div>
                </div>
                ${obj.description ? `<p class="text-muted small mt-1 mb-0">${escapeHtml(obj.description)}</p>` : ''}
              </div>
            `).join('')}
          </section>
        ` : '';

      // Styles pour la galerie de photos
      const photoGalleryStyles = `
              <style>
                .photo-gallery {
                  display: grid;
                  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                  gap: 1.5rem;
                  margin: 1.5rem 0;
                }
                .photo-card {
                  border-radius: 12px;
                  overflow: hidden;
                  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                  transition: transform 0.3s ease, box-shadow 0.3s ease;
                  background: white;
                }
                .photo-card:hover {
                  transform: translateY(-5px);
                  box-shadow: 0 8px 24px rgba(0,0,0,0.15);
                }
                .photo-img-container {
                  position: relative;
                  padding-top: 75%;
                  overflow: hidden;
                }
                .photo-img {
                  position: absolute;
                  top: 0;
                  left: 0;
                  width: 100%;
                  height: 100%;
                  object-fit: cover;
                  transition: transform 0.5s ease;
                }
                .photo-card:hover .photo-img {
                  transform: scale(1.05);
                }
                .photo-caption {
                  padding: 1rem;
                }
                .photo-meta {
                  display: flex;
                  align-items: center;
                  font-size: 0.85rem;
                  color: #6c757d;
                  margin-top: 0.5rem;
                }
                .photo-meta i {
                  margin-right: 0.5rem;
                  width: 16px;
                  text-align: center;
                }
                .photo-actions {
                  display: flex;
                  gap: 0.5rem;
                  margin-top: 1rem;
                  padding-top: 0.75rem;
                  border-top: 1px solid #eee;
                }
                .empty-photos {
                  text-align: center;
                  padding: 2rem;
                  background: #f8f9fa;
                  border-radius: 8px;
                  color: #6c757d;
                }
              </style>
            `;

      const photosSection = (() => {
        if (!photosList.length) return '';

        const resolvePhotoUrl = (photo) => {
          const candidates = [photo?.url, photo?.path, photo?.photoUrl, photo?.photo_url, photo?.file_url, photo?.imageUrl];
          const raw = candidates.find(Boolean);
          if (!raw) return '';
          try {
            return new URL(raw, window.location.origin).href;
          } catch {
            return raw;
          }
        };

        const photoCards = photosList.map((photo, index) => {
          const url = resolvePhotoUrl(photo);
          if (!url) return '';

          const caption = escapeHtml(photo.caption || photo.title || photo.description || `Photo de terrain ${index + 1}`);
          const rawTimestamp = photo.taken_at || photo.created_at || photo.timestamp || photo.date || photo.datetime;
          let timestampLabel = 'Date inconnue';

          if (rawTimestamp) {
            const ts = new Date(rawTimestamp);
            timestampLabel = Number.isFinite(ts.getTime()) ?
              ts.toLocaleDateString('fr-FR', { day: 'numeric', month: 'long', year: 'numeric' }) :
              rawTimestamp;
          }

          const locationLabel = photo.location || photo.place || photo.address || 'Localisation non pr√©cis√©e';

          return `
                  <div class="photo-card">
                    <div class="photo-img-container">
                      <img
                        src="${escapeHtml(url)}"
                        alt="${caption || 'Image sans description'}"
                        class="photo-img"
                        loading="lazy"
                      />
                    </div>
                    <div class="photo-caption">
                      <h6 class="mb-2">${caption}</h6>
                      <div class="photo-meta">
                        <i class="bi bi-calendar3"></i>
                        <span>${escapeHtml(timestampLabel)}</span>
                      </div>
                      <div class="photo-meta">
                        <i class="bi bi-geo-alt"></i>
                        <span>${escapeHtml(locationLabel)}</span>
                      </div>
                      <div class="photo-actions">
                        <a href="${escapeHtml(url)}" target="_blank" class="btn btn-sm btn-outline-primary w-100" download>
                          <i class="bi bi-download me-1"></i>T√©l√©charger
                        </a>
                      </div>
                    </div>
                  </div>
                `;
        }).filter(Boolean).join('');

        return `
                ${photoGalleryStyles}
            <section class="report-section">
              <div class="report-section-header">
                <div>
                      <h5><i class="bi bi-images me-2"></i>Galerie terrain</h5>
                      <small>${photosList.length} photo${photosList.length > 1 ? 's' : ''} de terrain</small>
                </div>
              </div>
                  ${photosList.length > 0 ? `
                    <div class="photo-gallery">
                      ${photoCards}
              </div>
                    <div class="text-end mt-2">
                      <small class="text-muted">Cliquez sur une photo pour la t√©l√©charger</small>
                    </div>
                  ` : `
                    <div class="empty-photos">
                      <i class="bi bi-camera-off fs-1 mb-2 d-block"></i>
                      <p class="mb-0">Aucune photo disponible pour cette p√©riode</p>
                    </div>
                  `}
            </section>
          `;
      })();

      // Styles pour la section IA
      const aiSectionStyles = `
              <style>
                .ai-section {
                  position: relative;
                }
                .ai-loading {
                  position: absolute;
                  top: 0;
                  left: 0;
                  right: 0;
                  bottom: 0;
                  background: rgba(255, 255, 255, 0.8);
                  display: flex;
                  flex-direction: column;
                  align-items: center;
                  justify-content: center;
                  border-radius: 8px;
                  z-index: 10;
                }
                .ai-summary-content {
                  white-space: pre-wrap;
                  line-height: 1.7;
                  background: #f8f9fa;
                  border-left: 4px solid #0d6efd;
                  padding: 1.25rem;
                  border-radius: 0 8px 8px 0;
                  position: relative;
                }
                .ai-summary-content:before {
                  content: '"\ 201C';
                  position: absolute;
                  top: 10px;
                  left: 15px;
                  font-size: 4rem;
                  color: rgba(13, 110, 253, 0.1);
                  font-family: Georgia, serif;
                  line-height: 1;
                  z-index: 0;
                }
                .ai-summary-text {
                  position: relative;
                  z-index: 1;
                }
                .ai-actions {
                  display: flex;
                  gap: 0.75rem;
                  margin-top: 1.5rem;
                  flex-wrap: wrap;
                }
                .ai-features {
                  display: flex;
                  gap: 0.5rem;
                  margin-top: 1rem;
                  flex-wrap: wrap;
                }
                .ai-feature-badge {
                  display: inline-flex;
                  align-items: center;
                  background: #e9ecef;
                  padding: 0.35rem 0.75rem;
                  border-radius: 20px;
                  font-size: 0.8rem;
                  color: #495057;
                }
                .ai-feature-badge i {
                  margin-right: 0.35rem;
                  color: #0d6efd;
                }
              </style>
            `;

      // Stocker les donn√©es du rapport pour le chatbot (avant de cr√©er la section)
      window.lastMonthlyReportData = report;
      window.lastAgentCompositeScore = agentCompositeScore;
      window.lastAgentTepRate = agentTepRate;
      window.lastPresenceRateValue = presenceRateValue;
      window.lastAgentFieldTimeHours = agentFieldTimeHours;
      window.lastAvgFieldTimePerDay = avgFieldTimePerDayValue;
      window.lastSelectedAgentEntry = selectedAgentEntry;
      window.lastSelectedAgentRank = selectedAgentRank;
      window.lastPresenceData = presenceData;
      window.lastActivitiesData = activitiesData;
      window.lastWorkingDaysValue = workingDaysValue;
      window.lastPlannedTotal = plannedTotal;
      window.lastRealizedTotal = realizedTotal;
      window.lastPartiallyTotal = partiallyTotal;
      window.lastInProgressTotal = inProgressTotal;
      window.lastNotRealizedTotal = notRealizedTotal;
      window.lastTotalAgents = totalAgents;

      const aiSection = `
              ${aiSectionStyles}
              <section class="report-section ai-section" id="ai-summary-section">
            <div class="report-section-header">
              <div>
                    <h5><i class="bi bi-robot me-2"></i>Analyse Intelligente</h5>
                    <small>Analyse et recommandations personnalis√©es avec IA</small>
              </div>
                  <div class="d-flex gap-2">
                    <button type="button"
                            class="btn btn-sm btn-success"
                            onclick="openChatGPTWhatsApp()"
                            title="Ouvrir WhatsApp avec ChatGPT">
                      <i class="bi bi-whatsapp me-1"></i>ChatGPT WhatsApp
                    </button>
                    <button type="button"
                            class="btn btn-sm btn-primary"
                            onclick="openGeminiChat()"
                            title="Ouvrir Gemini Chat">
                      <i class="bi bi-google me-1"></i>Gemini Chat
                    </button>
                    <button type="button"
                            class="btn btn-sm btn-outline-primary"
                            onclick="copyReportPrompt()"
                            title="Copier le rapport">
                      <i class="bi bi-clipboard me-1"></i>Copier
                    </button>
                    <button type="button"
                            class="btn btn-sm btn-outline-success"
                            onclick="generateAiSummary('detailed')"
                            title="Analyse classique">
                      <i class="bi bi-file-earmark-text me-1"></i>Analyse classique
              </button>
            </div>
                </div>
                <div class="position-relative">
              <style>
                .ai-chatbot-container {
                  background: white;
                  border-radius: 8px;
                  padding: 1.5rem;
                  margin-top: 1rem;
                }
              </style>
              ${commentsData.aiSummary ? `
                    <div class="ai-summary-content">
                      <div class="ai-summary-text">
                  ${commentsData.aiSummary}
                      </div>
                      <div class="ai-actions">
                        <button type="button" class="btn btn-sm btn-success" onclick="openChatGPTWhatsApp()">
                          <i class="bi bi-whatsapp me-1"></i>ChatGPT WhatsApp
                        </button>
                        <button type="button" class="btn btn-sm btn-primary" onclick="openGeminiChat()">
                          <i class="bi bi-google me-1"></i>Gemini Chat
                        </button>
                        <button type="button" class="btn btn-sm btn-outline-primary" onclick="copyReportPrompt()">
                          <i class="bi bi-clipboard me-1"></i>Copier
                        </button>
                        <button type="button" class="btn btn-sm btn-outline-secondary" onclick="regenerateAiSummary()">
                          <i class="bi bi-arrow-repeat me-1"></i>R√©g√©n√©rer
                        </button>
                        <button type="button" class="btn btn-sm btn-outline-secondary" onclick="copyAiSummary()">
                          <i class="bi bi-clipboard me-1"></i>Copier r√©sum√©
                        </button>
                      </div>
                      <div class="ai-features">
                        <span class="ai-feature-badge">
                          <i class="bi ${commentsData.aiModel?.includes('gemini') ? 'bi-google' : 'bi-lightning'}"></i>
                          ${commentsData.aiModel || 'Mod√®le IA'}
                        </span>
                        <span class="ai-feature-badge">
                          <i class="bi bi-calendar3"></i>
                          ${new Date().toLocaleDateString('fr-FR', { day: 'numeric', month: 'long', year: 'numeric' })}
                        </span>
                      </div>
                </div>
              ` : `
              <div class="ai-chatbot-container" id="huggingface-chatbot-container" style="display: block;">
                <div class="d-flex gap-2 justify-content-center flex-wrap mb-3">
                  <button type="button" class="btn btn-success btn-lg" onclick="openChatGPTWhatsApp()">
                    <i class="bi bi-whatsapp me-2"></i>ChatGPT WhatsApp
                        </button>
                  <button type="button" class="btn btn-primary btn-lg" onclick="openGeminiChat()">
                    <i class="bi bi-google me-2"></i>Gemini Chat
                        </button>
                </div>
                <div class="text-center">
                  <small class="text-muted">
                    Le rapport sera copi√© automatiquement. Collez-le (Ctrl+V) dans le chat.
                  </small>
                </div>
                      </div>
                      ${commentsData.fallbackSummary ? `
                        <div class="mt-4 p-3 bg-light rounded">
                          <p class="small mb-0 fw-medium">R√©sum√© automatique :</p>
                          <p class="small text-muted mb-0">${escapeHtml(commentsData.fallbackSummary)}</p>
                        </div>
                      ` : ''}
              `}
            </div>
          </section>
        `;

      // G√©n√©rer des recommandations personnalis√©es bas√©es sur les donn√©es r√©elles de l'agent
      const generatePersonalizedRecommendations = () => {
        const recommendations = [];
        const agentName = meta?.agent?.name || meta?.agent?.display_name || 'l\'agent';
        const firstName = agentName.split(' ')[0] || agentName;

        // Analyse du taux de pr√©sence
        if (presenceRateValue < 50) {
          recommendations.push({
            icon: 'exclamation-triangle',
            color: 'danger',
            priority: 1,
            title: 'Pr√©sence critique',
            text: `${firstName} a un taux de pr√©sence de ${presenceRateValue.toFixed(1)}% (${presenceData.workedDays || 0}/${workingDaysValue} jours). Une action urgente est n√©cessaire pour am√©liorer l'assiduit√©.`,
            action: 'Planifier un entretien pour identifier les obstacles et d√©finir un plan d\'am√©lioration.'
          });
        } else if (presenceRateValue < 70) {
          recommendations.push({
            icon: 'calendar-x',
            color: 'warning',
            priority: 2,
            title: 'Pr√©sence √† am√©liorer',
            text: `Avec ${presenceRateValue.toFixed(1)}% de pr√©sence, ${firstName} manque environ ${workingDaysValue - (presenceData.workedDays || 0)} jours ce mois.`,
            action: 'Viser au moins 80% de pr√©sence le mois prochain en r√©duisant les absences non justifi√©es.'
          });
        } else if (presenceRateValue >= 90) {
          recommendations.push({
            icon: 'trophy',
            color: 'success',
            priority: 5,
            title: 'Excellente pr√©sence',
            text: `F√©licitations ! ${firstName} affiche un excellent taux de pr√©sence de ${presenceRateValue.toFixed(1)}%.`,
            action: 'Maintenir ce niveau et partager les bonnes pratiques avec l\'√©quipe.'
          });
        }

        // Analyse du TEP (Taux d'Ex√©cution des Planifications)
        const totalPlanned = report.activities?.performance?.totalPlanned || 0;
        const realized = report.activities?.performance?.realized || 0;
        const notRealized = report.activities?.performance?.notRealized || 0;
        const partiallyRealized = report.activities?.performance?.partiallyRealized || 0;

        if (agentTepRate < 40 && totalPlanned > 0) {
          recommendations.push({
            icon: 'clipboard-x',
            color: 'danger',
            priority: 1,
            title: 'Ex√©cution critique',
            text: `Seulement ${agentTepRate.toFixed(1)}% des activit√©s planifi√©es ont √©t√© r√©alis√©es (${realized}/${totalPlanned}). ${notRealized} activit√©s n\'ont pas √©t√© r√©alis√©es.`,
            action: 'Revoir la charge de travail et prioriser les activit√©s cl√©s. Identifier les blocages.'
          });
        } else if (agentTepRate < 60 && totalPlanned > 0) {
          recommendations.push({
            icon: 'list-task',
            color: 'warning',
            priority: 2,
            title: 'Planification √† optimiser',
            text: `${firstName} a r√©alis√© ${agentTepRate.toFixed(1)}% de ses planifications. ${partiallyRealized} activit√©s sont partiellement r√©alis√©es.`,
            action: 'Mieux estimer la dur√©e des t√¢ches et √©viter la surplanification.'
          });
        } else if (agentTepRate >= 80 && totalPlanned > 5) {
          recommendations.push({
            icon: 'check2-all',
            color: 'success',
            priority: 5,
            title: 'Bonne ex√©cution',
            text: `${firstName} a r√©alis√© ${agentTepRate.toFixed(1)}% de ses ${totalPlanned} activit√©s planifi√©es.`,
            action: 'Continuer √† maintenir cette rigueur dans l\'ex√©cution des planifications.'
          });
        }

        // Analyse du temps terrain
        const avgFieldTimePerDay = (presenceData.workedDays || 1) > 0 ? agentFieldTimeHours / (presenceData.workedDays || 1) : 0;

        if (avgFieldTimePerDay < 3 && presenceData.workedDays > 5) {
          recommendations.push({
            icon: 'geo-alt',
            color: 'warning',
            priority: 2,
            title: 'Temps terrain limit√©',
            text: `${firstName} passe en moyenne ${avgFieldTimePerDay.toFixed(1)}h/jour sur le terrain (${formatFieldTimeDisplay(agentFieldTimeHours)} total).`,
            action: 'Optimiser les d√©placements et r√©duire le temps administratif pour augmenter le temps terrain.'
          });
        } else if (avgFieldTimePerDay >= 6) {
          recommendations.push({
            icon: 'geo-fill',
            color: 'success',
            priority: 5,
            title: 'Excellent temps terrain',
            text: `${firstName} passe en moyenne ${avgFieldTimePerDay.toFixed(1)}h/jour sur le terrain.`,
            action: 'Maintenir cet engagement terrain tout en veillant √† l\'√©quilibre travail-repos.'
          });
        }

        // Analyse des activit√©s non r√©alis√©es
        if (notRealized > 3) {
          recommendations.push({
            icon: 'exclamation-circle',
            color: 'danger',
            priority: 1,
            title: 'Activit√©s en souffrance',
            text: `${notRealized} activit√©s planifi√©es n\'ont pas √©t√© r√©alis√©es ce mois.`,
            action: 'Analyser les causes (surcharge, obstacles, manque de ressources) et reporter les activit√©s prioritaires.'
          });
        }

        // Analyse du score composite
        if (agentCompositeScore < 40) {
          recommendations.push({
            icon: 'graph-down-arrow',
            color: 'danger',
            priority: 1,
            title: 'Performance globale faible',
            text: `Le score composite de ${agentCompositeScore.toFixed(1)}/100 indique des difficult√©s sur plusieurs indicateurs.`,
            action: 'Mettre en place un accompagnement renforc√© et des objectifs progressifs.'
          });
        } else if (agentCompositeScore >= 75) {
          recommendations.push({
            icon: 'star-fill',
            color: 'success',
            priority: 5,
            title: 'Performance remarquable',
            text: `${firstName} obtient un score composite de ${agentCompositeScore.toFixed(1)}/100, ce qui est excellent.`,
            action: 'Reconna√Ætre cette performance et envisager des responsabilit√©s suppl√©mentaires.'
          });
        }

        // Analyse du rang dans le classement
        const agentRanking = report.projectRanking?.find(r =>
          String(r.agentId || r.agent_id || r.id) === String(meta?.agent?.id)
        );
        if (agentRanking && agentRanking.displayRank) {
          const totalAgents = report.projectRanking.length;
          const rankPercent = ((agentRanking.displayRank - 1) / Math.max(totalAgents - 1, 1)) * 100;

          if (agentRanking.displayRank <= 3) {
            recommendations.push({
              icon: 'award',
              color: 'success',
              priority: 4,
              title: 'Top 3 du projet',
              text: `${firstName} est class√©(e) ${agentRanking.displayRank}${agentRanking.displayRank === 1 ? 'er' : '√®me'} sur ${totalAgents} agents du projet.`,
              action: 'F√©liciter et encourager le partage d\'exp√©rience avec les coll√®gues.'
            });
          } else if (rankPercent > 70) {
            recommendations.push({
              icon: 'arrow-up-circle',
              color: 'info',
              priority: 3,
              title: 'Progression possible',
              text: `${firstName} est class√©(e) ${agentRanking.displayRank}√®me sur ${totalAgents}. Il y a une marge de progression.`,
              action: 'Identifier les indicateurs les plus faibles et d√©finir des objectifs cibl√©s.'
            });
          }
        }

        // Tri par priorit√© (1 = critique, 5 = encouragement)
        recommendations.sort((a, b) => a.priority - b.priority);

        return recommendations;
      };

      const personalizedRecs = generatePersonalizedRecommendations();

      // Section recommandations personnalis√©es
      const recommendationsSection = personalizedRecs.length > 0 ? `
              <section class="report-section">
                <div class="report-section-header">
                  <div>
                    <h5><i class="bi bi-lightbulb me-2"></i>Recommandations Personnalis√©es</h5>
                    <small>Bas√©es sur l'analyse des donn√©es de ${meta?.agent?.name || 'l\'agent'}</small>
                  </div>
                  <div class="report-chip-group">
                    <span class="report-chip">${personalizedRecs.filter(r => r.priority <= 2).length} prioritaire(s)</span>
                  </div>
                </div>
                <div class="row g-3">
                  ${personalizedRecs.map(rec => `
                    <div class="col-12 col-md-6">
                      <div class="card h-100 border-start border-4 border-${rec.color} shadow-sm">
                        <div class="card-body p-3">
                          <div class="d-flex align-items-start gap-2">
                            <div class="rounded-circle bg-${rec.color} bg-opacity-10 p-2">
                              <i class="bi bi-${rec.icon} text-${rec.color} fs-5"></i>
                            </div>
                            <div class="flex-grow-1">
                              <h6 class="mb-1 fw-semibold">${escapeHtml(rec.title)}</h6>
                              <p class="mb-2 small text-muted">${escapeHtml(rec.text)}</p>
                              <div class="d-flex align-items-center gap-1">
                                <i class="bi bi-arrow-right-circle text-${rec.color} small"></i>
                                <span class="small fw-medium text-${rec.color}">${escapeHtml(rec.action)}</span>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  `).join('')}
                </div>
              </section>
            ` : '';

      // G√©n√©rer les sections suppl√©mentaires
      const missionsStatsSection = renderMissionsStatsSection(presenceData);
      const zonesSection = renderZonesSection(presenceData.zones);
      const dailyMissionsSection = renderDailyMissionsSection(report.dailyMissions || [], referenceMonthLabel);
      
      // Section des lieux parcourus (depuis les check-ins)
      const visitedLocationsSection = renderVisitedLocationsSection(report.monthlyCheckins || []);

      // Construire le HTML complet du rapport
      const sections = [
        reportCoverSection,
        presenceSection,
        missionsStatsSection,
        dailyMissionsSection,  // Nouvelle section d√©taill√©e des missions quotidiennes
        visitedLocationsSection,  // Section d√©taill√©e des lieux parcourus
        zonesSection,
        visualizationSection,
        activitySection,
        rankingSection,
        recommendationsSection,
        objectivesSection,
        photosSection,
        aiSection
      ].filter(Boolean).join('\n');

      // Mettre √† jour le conteneur
      container.innerHTML = `
          <div class="monthly-report report-layout">
                ${sections}
          </div>
        `;

      // Initialiser le graphique radar de performance
      setTimeout(() => {
        const radarCanvas = document.getElementById('performanceRadarChart');
        if (radarCanvas && typeof Chart !== 'undefined') {
          const ctx = radarCanvas.getContext('2d');
          
          // R√©cup√©rer le temps terrain depuis diff√©rentes sources (y compris le classement)
          let chartFieldTimeHours = agentFieldTimeHours;
          if (chartFieldTimeHours === 0 && report.projectRanking && Array.isArray(report.projectRanking)) {
            const currentAgentId = meta?.agent?.id || lastMonthlyReportParams?.agentId;
            const agentRankingEntry = report.projectRanking.find(entry => 
              String(entry.agentId || entry.agent_id || entry.id) === String(currentAgentId)
            );
            if (agentRankingEntry) {
              chartFieldTimeHours = agentRankingEntry.fieldTimeHours || agentRankingEntry.field_time_hours || 0;
            }
          }
          
          // Calculer les valeurs pour le graphique radar
          const checkinsData = report.presence?.totalCheckins || 0;
          const workedDays = report.presence?.workedDays || 0;
          const plannedDays = report.presence?.plannedDays || report.activities?.plannedDays || 0;
          const avgCheckinsPerDay = workedDays > 0 ? Math.round((checkinsData / workedDays) * 10) / 10 : 0;
          const punctualityRate = plannedDays > 0 ? Math.round((workedDays / plannedDays) * 1000) / 10 : 0;
          const regularityScore = workedDays >= 5 ? Math.min(100, Math.round((workedDays / plannedDays) * 100)) : 0;
          const uniqueActivityTypes = new Set(activityList.map(a => (a.description || '').toLowerCase().substring(0, 30))).size;
          const diversityScore = plannedTotal > 0 ? Math.round((uniqueActivityTypes / Math.min(plannedTotal, 10)) * 100) : 0;
          const efficiencyHours = realizedTotal > 0 ? Math.round((chartFieldTimeHours / realizedTotal) * 10) / 10 : 0;
          const efficiencyScore = Math.min(100, (efficiencyHours / 4) * 100);
          // Normaliser le temps terrain (max 8h/jour * 20 jours = 160h = 100%)
          const fieldTimeScore = Math.min(100, (chartFieldTimeHours / 160) * 100);

          new Chart(ctx, {
            type: 'radar',
            data: {
              labels: [
                'Score Composite',
                'Pr√©sence',
                'Ex√©cution (TEP)',
                'Temps Terrain',
                'Ponctualit√©',
                'R√©gularit√©',
                'Diversit√©',
                'Efficacit√©'
              ],
              datasets: [{
                label: 'Performance',
                data: [
                  agentCompositeScore,
                  presenceRateValue,
                  agentTepRate,
                  fieldTimeScore,
                  punctualityRate,
                  regularityScore,
                  diversityScore,
                  efficiencyScore
                ],
                backgroundColor: 'rgba(13, 110, 253, 0.2)',
                borderColor: 'rgba(13, 110, 253, 1)',
                borderWidth: 2,
                pointBackgroundColor: 'rgba(13, 110, 253, 1)',
                pointBorderColor: '#fff',
                pointHoverBackgroundColor: '#fff',
                pointHoverBorderColor: 'rgba(13, 110, 253, 1)',
                pointRadius: 4,
                pointHoverRadius: 6
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  display: false
                },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      const label = context.dataset.label || '';
                      const value = context.parsed.r;
                      const labels = context.chart.data.labels;
                      const currentLabel = labels[context.dataIndex];
                      
                      // Formater les valeurs selon le type d'indicateur
                      if (currentLabel === 'Temps Terrain') {
                        return `${currentLabel}: ${formatFieldTimeDisplay(chartFieldTimeHours)} (${value.toFixed(1)}%)`;
                      } else if (currentLabel === 'Efficacit√©') {
                        return `${currentLabel}: ${efficiencyHours.toFixed(1)}h/activit√© (${value.toFixed(1)}%)`;
                      } else if (currentLabel === 'Diversit√©') {
                        return `${currentLabel}: ${uniqueActivityTypes} types (${value.toFixed(1)}%)`;
                      } else {
                        return `${currentLabel}: ${value.toFixed(1)}%`;
                      }
                    }
                  },
                  backgroundColor: 'rgba(0, 0, 0, 0.8)',
                  padding: 12,
                  titleFont: {
                    size: 14,
                    weight: 'bold'
                  },
                  bodyFont: {
                    size: 12
                  }
                }
              },
              scales: {
                r: {
                  beginAtZero: true,
                  max: 100,
                  min: 0,
                  ticks: {
                    stepSize: 20,
                    font: {
                      size: 11
                    },
                    color: '#6c757d'
                  },
                  grid: {
                    color: 'rgba(0, 0, 0, 0.1)',
                    lineWidth: 1
                  },
                  pointLabels: {
                    font: {
                      size: 12,
                      weight: 'bold'
                    },
                    color: '#495057',
                    padding: 10
                  }
                }
              },
              elements: {
                line: {
                  borderWidth: 2,
                  tension: 0.1
                }
              }
            }
          });
        }
      }, 100);

      // Afficher les boutons de t√©l√©chargement
      const reportActions = document.getElementById('report-actions');
      if (reportActions) {
        reportActions.classList.remove('d-none');
      }

      // Stocker les donn√©es du rapport pour le t√©l√©chargement
      window.currentReportData = {
        html: container.innerHTML,
        agentName: agentDisplayName,
        period: referenceMonthLabel,
        project: reportingProject,
        generatedAt: generationTimestamp
      };
    }

    // Initialisation du graphique de pr√©sence
    let presenceChart = null;

    function formatShortDate(date) {
      const d = new Date(date);
      const day = String(d.getDate()).padStart(2, '0');
      const month = String(d.getMonth() + 1).padStart(2, '0');
      return `${day}/${month}`;
    }

    async function fetchPresenceData(days) {
      try {
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(endDate.getDate() - days);

        startDate.setHours(0, 0, 0, 0);
        endDate.setHours(23, 59, 59, 999);

        const userParam = dashboardAgentId ? `&user_id=${dashboardAgentId}` : '';
        const response = await fetch(`/api/checkins?from=${startDate.toISOString()}&to=${endDate.toISOString()}${userParam}`, {
          headers: { 'Content-Type': 'application/json' }
        });

        if (!response.ok) {
          throw new Error(`Erreur ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        const checkins = Array.isArray(data) ? data : (data.checkins || data.data || []);
        const dailyData = {};

        // Initialiser les jours avec 0
        for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
          dailyData[formatShortDate(d)] = 0;
        }

        // Compter les check-ins par jour
        checkins.forEach(checkin => {
          const date = new Date(checkin.timestamp || checkin.created_at);
          const dateKey = formatShortDate(date);
          dailyData[dateKey] = (parseFloat(dailyData[dateKey] || 0) + 1);
        });

        return {
          labels: Object.keys(dailyData),
          data: Object.values(dailyData)
        };
      } catch (error) {
        console.error('Erreur lors de la r√©cup√©ration des donn√©es de pr√©sence:', error);
        return { labels: [], data: [] };
      }
    }

    async function initPresenceChart() {
      const periodSelect = document.getElementById('period-select');
      if (!periodSelect) return;

      const days = parseInt(periodSelect.value, 10) || 30;
      const chartContainer = document.querySelector('.chart-container');

      if (!chartContainer) return;

      chartContainer.innerHTML = `
                <div class="text-center py-4">
                  <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Chargement...</span>
                  </div>
                  <p class="mt-2">Chargement des donn√©es de pr√©sence...</p>
                </div>
              `;

      try {
        const { labels, data } = await fetchPresenceData(days);

        chartContainer.innerHTML = '<canvas id="presenceChart"></canvas>';

        const ctx = document.getElementById('presenceChart').getContext('2d');

        if (presenceChart) {
          presenceChart.destroy();
        }

        presenceChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets: [{
              label: 'Heures de pr√©sence',
              data,
              backgroundColor: 'rgba(102, 126, 234, 0.2)',
              borderColor: 'rgba(102, 126, 234, 1)',
              borderWidth: 2,
              tension: 0.3,
              fill: true,
              pointBackgroundColor: 'rgba(255, 255, 255, 1)',
              pointBorderColor: 'rgba(102, 126, 234, 1)',
              pointBorderWidth: 2,
              pointRadius: 4,
              pointHoverRadius: 6
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                position: 'top'
              },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    return `${context.parsed.y} heures`;
                  }
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Heures de pr√©sence',
                  font: { weight: 'bold' }
                },
                ticks: {
                  stepSize: 1,
                  callback: value => `${value}h`
                }
              },
              x: {
                title: {
                  display: true,
                  text: 'Date',
                  font: { weight: 'bold' }
                }
              }
            }
          }
        });
      } catch (error) {
        console.error('Erreur lors de l\'initialisation du graphique:', error);
        chartContainer.innerHTML = `
        <div class="alert alert-danger">
          <i class="bi bi-exclamation-triangle-fill me-2"></i>
          Erreur lors du chargement du graphique de pr√©sence.
        </div>
      `;
      }
    }

    // Initialisation des √©couteurs d'√©v√©nements
    // Fonction utilitaire pour trouver un agent par son ID
    function findAgentById(agentId) {
      if (!agentId) return null;
      const agentSelect = document.getElementById('report-agent-select');
      if (!agentSelect) return null;

      const option = Array.from(agentSelect.options).find(opt => opt.value === agentId);
      if (!option) return null;

      return {
        id: option.value,
        name: option.text,
        project: option.dataset.project || null
      };
    }

    function initializeEventListeners() {
      // Initialisation des s√©lecteurs
      const monthSelect = document.getElementById('report-month-select');
      const agentSelect = document.getElementById('report-agent-select');
      const projectSelect = document.getElementById('report-project-select');
      const generateBtn = document.getElementById('generate-report-btn');
      const periodSelect = document.getElementById('period-select');

      // Initialisation des valeurs par d√©faut
      if (monthSelect) {
        const now = new Date();
        const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        monthSelect.value = currentMonth;
        dashboardMonthFilter = currentMonth;
      }

      // Gestion des changements de projet
      if (projectSelect) {
        projectSelect.addEventListener('change', (event) => {
          projectSelectTouched = true;
          dashboardProjectFilter = event.target.value || '';

          // Mise √† jour du filtre du classement pour correspondre au filtre du projet
          if (dashboardProjectFilter) {
            const formattedProject = formatProjectDisplay(dashboardProjectFilter);
            if (leaderboardProjects.length === 0 || leaderboardProjects.includes(formattedProject)) {
              leaderboardProjectFilter = formattedProject;
              if (leaderboardCache.length > 0) {
                renderLeaderboardTable();
              }
            }
          } else {
            leaderboardProjectFilter = null;
            if (leaderboardCache.length > 0) {
              renderLeaderboardTable();
            }
          }
        });
      }

      // Gestion des changements d'agent
      if (agentSelect) {
        agentSelect.addEventListener('change', (event) => {
          const agent = findAgentById(event.target.value);
          if (agent && !projectSelectTouched) {
            syncProjectSelectWithAgent(agent);
          }
        });
      }

      // Gestion du bouton de g√©n√©ration
      if (generateBtn) {
        generateBtn.addEventListener('click', async () => {
          generateBtn.disabled = true;
          try {
            await applyDashboardFilter();
          } finally {
            generateBtn.disabled = false;
          }
        });
      }

      // Gestion du changement de p√©riode pour le graphique
      if (periodSelect) {
        periodSelect.addEventListener('change', () => {
          initPresenceChart().catch(err => {
            console.warn('Erreur lors du chargement du graphique:', err);
          });
        });
      }

      // Chargement initial
      applyDashboardFilter({ skipValidation: true })
        .then(() => initPresenceChart())
        .catch(err => {
          console.error('Erreur lors du chargement initial:', err);
        });
    }

    // Initialiser les √©couteurs d'√©v√©nements au chargement du DOM
    function initializeApp() {
      try {
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initializeEventListeners);
        } else {
          initializeEventListeners();
        }
      } catch (error) {
        console.error('Erreur lors de l\'initialisation de l\'application:', error);
        // Afficher un message d'erreur convivial
        const errorContainer = document.getElementById('error-container') || document.body;
        errorContainer.innerHTML = `
          <div class="alert alert-danger m-3" role="alert">
            <h4 class="alert-heading">Erreur de chargement</h4>
            <p>Une erreur est survenue lors du chargement de l'application. Veuillez rafra√Æchir la page.</p>
            <hr>
            <p class="mb-0 small">D√©tails techniques: ${escapeHtml(error.message)}</p>
          </div>
        `;
        throw error; // Propager l'erreur pour le suivi
      }
    }

    // Exposer les fonctions globalement
    window.initializeApp = initializeApp;
    window.initializeEventListeners = initializeEventListeners;

    // Fonction pour t√©l√©charger le rapport en HTML
    // Fonction pour convertir les canvas en images base64
    async function convertCanvasToImages(htmlContent) {
      // D'abord, convertir les canvas du DOM r√©el en images
      const reportContainer = document.getElementById('monthly-report-container');
      const realCanvases = reportContainer ? Array.from(reportContainer.querySelectorAll('canvas')) : [];
      const canvasMap = new Map();
      
      // Convertir chaque canvas r√©el en image base64
      for (const canvas of realCanvases) {
        try {
          // S'assurer que le canvas est visible et rendu
          const rect = canvas.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            const dataURL = canvas.toDataURL('image/png', 1.0);
            const canvasId = canvas.id || canvas.getAttribute('id') || `canvas_${Math.random().toString(36).substr(2, 9)}`;
            canvasMap.set(canvasId, dataURL);
            console.log(`Canvas ${canvasId} converti en image (${rect.width}x${rect.height})`);
          }
        } catch (e) {
          console.warn('Erreur lors de la conversion du canvas:', e);
        }
      }
      
      // Maintenant, remplacer les canvas dans le HTML par des images
      const container = document.createElement('div');
      container.innerHTML = htmlContent;
      const htmlCanvases = container.querySelectorAll('canvas');
      
      for (const canvas of htmlCanvases) {
        try {
          const canvasId = canvas.id || canvas.getAttribute('id');
          let dataURL = canvasId ? canvasMap.get(canvasId) : null;
          
          // Si pas trouv√© dans la map, essayer de trouver par position ou cr√©er une image placeholder
          if (!dataURL) {
            // Chercher dans la map par index ou cr√©er un placeholder
            const index = Array.from(htmlCanvases).indexOf(canvas);
            if (index < realCanvases.length && realCanvases[index]) {
              try {
                dataURL = realCanvases[index].toDataURL('image/png', 1.0);
              } catch (e) {
                console.warn('Impossible de convertir le canvas par index:', e);
              }
            }
          }
          
          if (dataURL) {
            const img = document.createElement('img');
            img.src = dataURL;
            img.style.maxWidth = '100%';
            img.style.height = 'auto';
            img.style.display = 'block';
            img.style.margin = '10px auto';
            img.style.border = '1px solid #dee2e6';
            img.style.borderRadius = '4px';
            img.alt = canvasId || 'Graphique';
            img.className = 'exported-chart-image';
            
            // Pr√©server les dimensions si disponibles
            if (canvas.width) img.width = canvas.width;
            if (canvas.height) img.height = canvas.height;
            
            // Remplacer le canvas par l'image
            canvas.replaceWith(img);
          } else {
            // Si pas de conversion possible, cr√©er un placeholder
            const placeholder = document.createElement('div');
            placeholder.style.cssText = 'padding:20px;background:#f8f9fa;border:1px dashed #dee2e6;border-radius:4px;text-align:center;color:#6c757d;';
            placeholder.innerHTML = `<i class="bi bi-image"></i><br><small>Graphique non disponible dans l'export</small>`;
            canvas.replaceWith(placeholder);
          }
        } catch (e) {
          console.warn('Erreur lors du remplacement du canvas:', e);
        }
      }
      
      return container.innerHTML;
    }

    // Fonction pour g√©n√©rer la documentation des indicateurs
    function generateIndicatorsDocumentation() {
      return `
        <section class="report-section">
          <div class="report-section-header">
            <div>
              <h5><i class="bi bi-info-circle me-2"></i>Documentation des Indicateurs de Performance</h5>
              <small>Guide d'interpr√©tation des indicateurs et seuils de performance</small>
            </div>
          </div>
          
          <div class="row">
            <div class="col-md-6 mb-4">
              <div class="card h-100 border-primary">
                <div class="card-header bg-primary text-white">
                  <h6 class="mb-0"><i class="bi bi-calendar-check me-2"></i>Pr√©sence (Poids: 70%)</h6>
                </div>
                <div class="card-body">
                  <p class="card-text"><strong>D√©finition :</strong> Pourcentage de jours de pr√©sence sur les jours ouvr√©s du mois.</p>
                  <hr>
                  <h6>Seuils d'interpr√©tation :</h6>
                  <ul class="list-unstyled">
                    <li><span class="badge bg-success">‚â•90%</span> <strong>Excellent</strong> - Assiduit√© remarquable, tr√®s fiable</li>
                    <li><span class="badge bg-info">80-89%</span> <strong>Bon</strong> - Bonne assiduit√©, quelques absences justifi√©es</li>
                    <li><span class="badge bg-warning text-dark">70-79%</span> <strong>Moyen</strong> - Assiduit√© acceptable mais √† am√©liorer</li>
                    <li><span class="badge bg-danger">50-69%</span> <strong>Faible</strong> - Trop d'absences, action corrective n√©cessaire</li>
                    <li><span class="badge bg-dark"><50%</span> <strong>Critique</strong> - Situation pr√©occupante, intervention urgente requise</li>
                  </ul>
                </div>
              </div>
            </div>
            
            <div class="col-md-6 mb-4">
              <div class="card h-100 border-success">
                <div class="card-header bg-success text-white">
                  <h6 class="mb-0"><i class="bi bi-check2-square me-2"></i>TEP - Taux d'Ex√©cution (Poids: 15%)</h6>
                </div>
                <div class="card-body">
                  <p class="card-text"><strong>D√©finition :</strong> Pourcentage d'activit√©s planifi√©es qui ont √©t√© totalement r√©alis√©es.</p>
                  <hr>
                  <h6>Seuils d'interpr√©tation :</h6>
                  <ul class="list-unstyled">
                    <li><span class="badge bg-success">‚â•90%</span> <strong>Excellent</strong> - Excellente capacit√© d'ex√©cution, planification r√©aliste</li>
                    <li><span class="badge bg-info">80-89%</span> <strong>Bon</strong> - Bon taux d'ex√©cution, planification g√©n√©ralement adapt√©e</li>
                    <li><span class="badge bg-warning text-dark">70-79%</span> <strong>Moyen</strong> - Taux moyen, possible sur-planification ou difficult√©s d'ex√©cution</li>
                    <li><span class="badge bg-danger">50-69%</span> <strong>Faible</strong> - Difficult√©s √† ex√©cuter les planifications, r√©vision n√©cessaire</li>
                    <li><span class="badge bg-dark"><50%</span> <strong>Critique</strong> - Probl√®me majeur d'ex√©cution, analyse approfondie requise</li>
                  </ul>
                </div>
              </div>
            </div>
            
            <div class="col-md-6 mb-4">
              <div class="card h-100 border-info">
                <div class="card-header bg-info text-white">
                  <h6 class="mb-0"><i class="bi bi-geo-alt me-2"></i>Temps Terrain (Poids: 15%)</h6>
                </div>
                <div class="card-body">
                  <p class="card-text"><strong>D√©finition :</strong> Nombre total d'heures pass√©es sur le terrain pendant le mois.</p>
                  <hr>
                  <h6>Seuils d'interpr√©tation :</h6>
                  <ul class="list-unstyled">
                    <li><span class="badge bg-success">‚â•100h</span> <strong>Excellent</strong> - Engagement terrain tr√®s √©lev√©, disponibilit√© maximale</li>
                    <li><span class="badge bg-info">80-99h</span> <strong>Bon</strong> - Bon engagement terrain, pr√©sence r√©guli√®re sur le terrain</li>
                    <li><span class="badge bg-warning text-dark">60-79h</span> <strong>Moyen</strong> - Engagement moyen, peut √™tre am√©lior√©</li>
                    <li><span class="badge bg-danger">40-59h</span> <strong>Faible</strong> - Engagement insuffisant, besoin d'augmenter le temps terrain</li>
                    <li><span class="badge bg-dark"><40h</span> <strong>Insuffisant</strong> - Tr√®s faible pr√©sence terrain, action prioritaire</li>
                  </ul>
                </div>
              </div>
            </div>
            
            <div class="col-md-6 mb-4">
              <div class="card h-100 border-warning">
                <div class="card-header bg-warning text-dark">
                  <h6 class="mb-0"><i class="bi bi-star me-2"></i>Score Composite</h6>
                </div>
                <div class="card-body">
                  <p class="card-text"><strong>D√©finition :</strong> Score global calcul√© √† partir de la moyenne pond√©r√©e des trois indicateurs principaux.</p>
                  <p class="small text-muted">Formule : (Pr√©sence √ó 70%) + (TEP √ó 15%) + (Temps Terrain √ó 15%)</p>
                  <hr>
                  <h6>Seuils d'interpr√©tation :</h6>
                  <ul class="list-unstyled">
                    <li><span class="badge bg-success">‚â•90</span> <strong>Excellent</strong> - Performance globale remarquable, agent mod√®le</li>
                    <li><span class="badge bg-info">80-89</span> <strong>Bon</strong> - Bonne performance globale, quelques axes d'am√©lioration</li>
                    <li><span class="badge bg-warning text-dark">70-79</span> <strong>Moyen</strong> - Performance acceptable mais n√©cessite des am√©liorations</li>
                    <li><span class="badge bg-danger">60-69</span> <strong>Faible</strong> - Performance insuffisante, plan d'action n√©cessaire</li>
                    <li><span class="badge bg-dark"><60</span> <strong>Critique</strong> - Performance pr√©occupante, accompagnement intensif requis</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
          
          <div class="alert alert-info mt-3">
            <h6><i class="bi bi-lightbulb me-2"></i>Conseils d'interpr√©tation :</h6>
            <ul class="mb-0">
              <li><strong>Pr√©sence √©lev√©e + TEP √©lev√©</strong> = Agent tr√®s performant et fiable</li>
              <li><strong>Pr√©sence √©lev√©e + TEP faible</strong> = Possible sur-planification ou difficult√©s d'organisation</li>
              <li><strong>Pr√©sence faible + TEP √©lev√©</strong> = Agent efficace mais assiduit√© √† am√©liorer</li>
              <li><strong>Temps terrain √©lev√© + TEP faible</strong> = Possible dispersion ou activit√©s non planifi√©es</li>
              <li><strong>Temps terrain faible + TEP √©lev√©</strong> = Efficacit√© mais engagement terrain √† renforcer</li>
            </ul>
          </div>
        </section>
      `;
    }

    window.downloadReportHTML = async function () {
      const reportContainer = document.getElementById('monthly-report-container');
      if (!reportContainer || !reportContainer.innerHTML.trim()) {
        alert('Aucun rapport √† t√©l√©charger. Veuillez d\'abord g√©n√©rer un rapport.');
        return;
      }

      // Afficher un indicateur de chargement
      const loadingMsg = document.createElement('div');
      loadingMsg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:white;padding:20px;border-radius:8px;z-index:10000;';
      loadingMsg.innerHTML = 'Pr√©paration de l\'export HTML...<br><small>Conversion des graphiques en cours...</small>';
      document.body.appendChild(loadingMsg);

      try {
        // Attendre un peu pour s'assurer que les graphiques sont rendus
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Cloner le contenu pour ne pas modifier l'original
        const clonedContent = reportContainer.cloneNode(true);
        
        // Convertir les canvas en images
        let htmlWithImages = await convertCanvasToImages(clonedContent.innerHTML);
        
        // Ajouter la documentation des indicateurs avant la fin
        const indicatorsDoc = generateIndicatorsDocumentation();
        htmlWithImages = htmlWithImages + indicatorsDoc;

        const reportData = window.currentReportData || {};
      const agentName = (reportData.agentName || 'Agent').replace(/[^a-zA-Z0-9√Ä-√ø\s]/g, '').replace(/\s+/g, '_');
      const period = (reportData.period || 'rapport').replace(/[^a-zA-Z0-9√Ä-√ø\s]/g, '').replace(/\s+/g, '_');
      const filename = `Rapport_${agentName}_${period}.html`;

        // R√©cup√©rer tous les styles CSS de la page
        const allStyles = Array.from(document.styleSheets)
          .map(sheet => {
            try {
              return Array.from(sheet.cssRules || [])
                .map(rule => rule.cssText)
                .join('\n');
            } catch (e) {
              return '';
            }
          })
          .filter(Boolean)
          .join('\n');

        const htmlContent = `<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rapport Mensuel - ${escapeHtml(reportData.agentName || 'Agent')} - ${escapeHtml(reportData.period || '')}</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
  <style>
    ${allStyles}
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      padding: 20px;
      background: #f8f9fa;
    }
    .monthly-report { max-width: 95%; margin: 0 auto; padding: 0 30px; width: 100%; }
    #monthly-report-container { width: 100%; max-width: 100%; }
    .report-section {
      background: white;
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    .report-section-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 1rem;
      flex-wrap: wrap;
      gap: 1rem;
    }
    .report-section-header h5 { margin: 0; color: #2c3e50; }
    .report-chip {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      background: #e9ecef;
      border-radius: 20px;
      font-size: 0.85rem;
      margin-right: 0.5rem;
    }
    .report-chip-group { display: flex; flex-wrap: wrap; gap: 0.5rem; }
    .report-metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
    }
    .report-metric-card {
      text-align: center;
      padding: 1rem;
      background: #f8f9fa;
      border-radius: 8px;
    }
    .metric-value { font-size: 1.5rem; font-weight: bold; color: #2c3e50; }
    .metric-label { font-size: 0.85rem; color: #6c757d; }
    .report-cover-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }
    .report-cover-details .detail { padding: 0.75rem; background: #f8f9fa; border-radius: 8px; }
    .report-cover-details .label { font-size: 0.8rem; color: #6c757d; }
    .report-cover-details .value { font-weight: 600; color: #2c3e50; }
    .table { font-size: 0.9rem; }
    .print-header {
      text-align: center;
      margin-bottom: 2rem;
      padding-bottom: 1rem;
      border-bottom: 2px solid #dee2e6;
    }
    .print-header h1 { color: #2c3e50; margin-bottom: 0.5rem; }
    .print-header p { color: #6c757d; margin: 0; }
    img { max-width: 100%; height: auto; }
    @media print {
      body { padding: 0; background: white; }
      .report-section { box-shadow: none; border: 1px solid #dee2e6; }
      .no-print { display: none !important; }
    }
  </style>
</head>
<body>
  <div class="print-header no-print">
    <h1><i class="bi bi-file-text me-2"></i>Rapport Mensuel</h1>
    <p>${escapeHtml(reportData.agentName || 'Agent')} - ${escapeHtml(reportData.period || '')} - ${escapeHtml(reportData.project || '')}</p>
    <p class="text-muted small">G√©n√©r√© le ${escapeHtml(reportData.generatedAt || new Date().toLocaleString('fr-FR'))}</p>
    <button class="btn btn-primary mt-3 no-print" onclick="window.print()">
      <i class="bi bi-printer me-1"></i>Imprimer
    </button>
  </div>
  <div class="monthly-report report-layout">
    ${htmlWithImages}
  </div>
</body>
</html>`;

      const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
        
        alert('‚úÖ Rapport HTML t√©l√©charg√© avec succ√®s !\n\nLe fichier inclut :\n- Tous les graphiques convertis en images\n- La documentation compl√®te des indicateurs\n- Tous les styles et couleurs');
      } catch (error) {
        console.error('Erreur lors de l\'export:', error);
        alert('‚ùå Erreur lors de l\'export du rapport. Veuillez r√©essayer.');
      } finally {
        document.body.removeChild(loadingMsg);
      }
    };

    // Fonction pour imprimer le rapport
    window.printReport = function () {
      const reportContainer = document.getElementById('monthly-report-container');
      if (!reportContainer || !reportContainer.innerHTML.trim()) {
        alert('Aucun rapport √† imprimer. Veuillez d\'abord g√©n√©rer un rapport.');
        return;
      }

      const reportData = window.currentReportData || {};
      const printWindow = window.open('', '_blank');

      printWindow.document.write(`
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Rapport - ${escapeHtml(reportData.agentName || 'Agent')}</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
  <style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; padding: 20px; }
    .monthly-report { max-width: 100%; }
    .report-section { background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 1rem; margin-bottom: 1rem; page-break-inside: avoid; }
    .report-section-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem; }
    .report-section-header h5 { margin: 0; }
    .report-chip { display: inline-block; padding: 0.2rem 0.5rem; background: #e9ecef; border-radius: 15px; font-size: 0.8rem; margin-right: 0.3rem; }
    .report-chip-group { display: flex; flex-wrap: wrap; gap: 0.3rem; }
    .report-metrics-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem; }
    .report-metric-card { text-align: center; padding: 0.75rem; background: #f8f9fa; border-radius: 6px; }
    .metric-value { font-size: 1.2rem; font-weight: bold; }
    .metric-label { font-size: 0.75rem; color: #6c757d; }
    .report-cover-details { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem; margin-top: 0.75rem; }
    .report-cover-details .detail { padding: 0.5rem; background: #f8f9fa; border-radius: 6px; }
    .report-cover-details .label { font-size: 0.7rem; color: #6c757d; }
    .report-cover-details .value { font-weight: 600; font-size: 0.85rem; }
    .table { font-size: 0.8rem; }
    @page { size: A4; margin: 15mm; }
  </style>
</head>
<body>
  ${reportContainer.innerHTML}
</body>
</html>`);

      printWindow.document.close();
      printWindow.onload = function () {
        printWindow.print();
      };
    };

    // D√©marrer l'application
    document.addEventListener('DOMContentLoaded', function () {
      try {
        initializeApp();
      } catch (error) {
        console.error('Erreur lors de l\'initialisation de l\'application:', error);
        alert('Une erreur est survenue lors du chargement du tableau de bord. Veuillez rafra√Æchir la page.');
      }
    });
  </script>
</body>
</html>
</html>